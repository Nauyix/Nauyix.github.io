[{"title":"linux多进程开发","date":"2023-04-25T11:34:49.000Z","url":"/2023/04/25/process/","categories":[[" ",""]],"content":"程序和进程进程是正在运行的程序的实例，是操作系统动态执行的基本单元可以使用一个程序创建多个进程 单道和多道单道技术：计算机内存中只允许一个程序运行多道技术：为提高cpu利用率，允许同时在计算机内存中存放几道相互独立的程序，使他们在管理程序的控制下，相互穿插运行，共享系统资源 时间片操作系统分配给每一个正在进行的进程微观上的一段cpu时间 并行和并发并行（Parallel）：同一时刻有多条指令在多个处理器上同时进行并发（Concurrent）：同一时刻只能由一条指令执行，但是多个进程指令被快速的轮换交替执行，使其看起来使多个进程同时执行 进程控制块（PCB）内核为进程所做的事情进行清楚地描述，linux内核的进程控制块使task_srtuct结构体(位于&#x2F;usr&#x2F;src&#x2F;linux-headers-xxx&#x2F;include&#x2F;linux&#x2F;sched.h)主要包含：进程id，进程状态，进程切换时需要保存或回复的cpu寄存器，描述虚拟地址空间的信息，描述控制终端的信息，当前工作目录，umask掩码，文件描述符表，信号量，用户id组id，会话和进程组，进程资源上限等 进程状态转换三态模型：就绪态，运行态，稳定态五态模型：新建态，[三态模型]，终止态就绪态：进程具备运行条件，等待分配处理器，系统会形成一个就绪队列运行态：进程占用处理器正在运行阻塞态：又叫等待态&#x2F;睡眠态，进程不具备运行条件或等待某一事件完成如何查看进程状态 进程创建 原理父子进程均独立拥有PCB，拷贝后内存块内用户区内容一致，内核区会有所区别实际上：fork是通过读时共享，写时拷贝实现的，资源在fork后并不立即拷贝，此时为只读共享状态，只有在写入时才会复制地址空间但值得注意的是：刚被创建出，两个进程均未执行任何写操作时，父子进程共享文件表，相同的文件描述符指向相同的文件表，引用计数增加 gdb调试gdb默认只跟踪一个进程，可以在调用前设置跟踪某一进程 默认为on，表示调试当前进程时其他进程继续运行info inferiors 查看当前调试的所有进程inferior [id] 切换当前调试的进程注意：需要通过info inferiors查看id，切换时需要输入的是id，不是piddetach inferiors [id] 使进程脱离gdb调试独立运行 exec函数族作用：根据指定的文件名找到可执行文件，然后替换调用进程中的内容，一般会创建子进程，然后在子进程中执行exec，子进程中所有的代码都会被替换，即便exec的内容结束，也并不会执行之后的任何代码 参数 指代 作用 l list 参数地址列表 v vector 存有参数地址的指针数组的地址 p path 按path环境变量指定的目录搜索可执行文件 e environment 存有环境变量字符串地址的指针数组的地址 最初的exec版本： 其他的所有exec族都是对execve的封装 进程控制 孤儿进程定义：父进程终止运行，但仍在运行的子进程孤儿进程的附近成为init，init会循环wait()它的已经退出的子进程，当孤儿进程结束时，init会代为处理善后（调用_wait()）注意：在部分发行版中，孤儿进程并不一定被init收养，但等效 僵尸进程进程结束之后，会释放用户区数据，但是PCB是由父进程释放的，如果进程终止时父进程没有回收PCB，则会造成占用进程号的僵尸进程出现僵尸进程不可以被kill -9杀死 解决方案：让父进程死亡，让init接手该进程，会自动回收 wait函数 进程间通信（IPC）目的：数据传输、通知事件、资源共享、进程控制等linux中进程通信的方式（共7种）： 同一主机进程间通信 Unix进程间通信方式 匿名管道 有名管道 信号 System V进程间通信方式&#x2F;POSIX进程间通信方式 消息队列 共享内存 信号量 不同主机间进程通信方式 Socket套接字 匿名管道匿名管道是UNIX系统IPC的最古老形式管道的特点： 是一个在内核内存中维护的缓冲器，存储能力有限，在不同操作系统中大小不一定相同 可以读写，匿名管道没有文件实体，有名管道由文件实体但不存储数据，可以按照操作文件的形式操作管道 一个管道是一个字节流，不存在消息或边界的概念，可以读取任意大小的数据块，不管写入的数据块是多少 通过管道传递的顺序是顺序的，读取和写出的顺序完全一致 数据传输是单向的，一端可以写入，一端可以读出 管道读取数据的操作是一次性的，一旦读取便会被遗弃 匿名管道只能在具有公共祖先的进程间使用 管道的数据结构：循环队列但是，如果管道已满仍然写，write会阻塞 管道的读写特点使用管道时需要注意的情况（假设都是阻塞I&#x2F;O操作）： 所有的指向管道写端的文件描述符都关闭时，即写端的引用计数为0，如果有进程从管道的读端读取数据，那么管道中所有的数据被读取以后，再次read会返回0，效果同读到文件末尾 上一种情况，如果有写端没有关闭，即写端的引用计数不为0，read会阻塞 如果读端的引用计数为0，如果有进程写数据，该进程会收到一个SIGPIPE的信号，通常会导致进程异常终止 如果有指向管道读端的文件描述符没有关闭，即管道的读端引用计数大于0，而持有管道读端的进程也没有从管道中读数据，此时有进程向管道中写数据，那么管道被写满时write会被阻塞，直到管道中有空位置时并成功写入时才可以返回 "},{"title":"SpringMVC","date":"2023-04-18T14:30:21.000Z","url":"/2023/04/18/SpringMVC/","categories":[[" ",""]],"content":"关于SpringMVC基于MVC开发模式的框架，用来优化控制器，也是spring家族的一员，同样具备IoC和AOP 优点 轻量级，基于MVC架构 易上手，易理解 具备IoC和AOP 完全基于注解开发 基本开发步骤 新建项目，选择webapp模板 修改目录，添加缺失的test,java,resources(*2)，并修改目录属性 修改pom.xml，添加springMVC依赖，添加servlet的依赖 添加springmvc.xml配置文件，指定扫描包，添加视图解析器 删除web.xml(原有版本过低)，新建web.xml 在web.xml中注册springMVC框架(请求基于servlet) 删除index.jsp，新建，发送请求给服务器 开发控制器(servlet)，它是一个普通的类 如何实操 访问权限public 返回值任意 名称任意 参数任意，可以为空 使用@RequeseMapping来声明访问路径（可以分级） @RequestMapping 可以加在方法或类上，指定该方法(或类)的访问路径 可以约定请求提交方式 数据提交方式的优化散提数据 对象封装在提交请求中保证请求参数的名称与实体类中成员变量一致则可以自动提交数据，自动类型转换，自动封装数据到对象中 动态占位符提交仅限于超链接或地址栏直接提交，一杠一值 映射参数名称不一致提交的参数名和形参不一致，使用@RequestParam解析 手工提取数据 如何解决中文乱码的问题配置过滤器-&gt;web.xml servlet方法的返回值String客户端资源的地址，自动拼接前缀后缀，可以屏蔽自动拼接字符串，可以指定返回路径 Object返回json格式的对象，自动将对象或集合转为json，依赖jackson工具，一般用于ajax请求 void一般用于ajax请求 基本数据类型用于ajax请求 ModelAndView返回数据和试图对象，现在用的很少 完成ajax请求访问服务器，返回学生集合 添加jackson依赖 在webapp下新建js目录，添加jQuery函数库 在index.jsp上导入函数库 在action上添加注解@ResponseBody，用来处理ajax请求 在springMVC.xml文件中添加注解驱动&lt;mvc:annotationdriven&#x2F;&gt;，用于解析@ResponseBody注解 SpringMVC的四种跳转方式实质：[请求转发，重定向]到[页面，action]请求转发和重定向最大的不同：请求转发地址栏不变，重定向地址栏改变 SpringMVC默认的参数类型 HttpServletRequest HttpServletResponse HttpSession Model Map ModelMap直接拿来即可用，作用域：Request，所以只有forward时数据仍然存在，如果使用redirect，则需要使用session保存数据 页面上日期的显示日期提交 单个日期处理使用注解@DateTimeFormat()，必须搭配springMVC配置文件中&lt;mvc:annontationdriven\\&gt;共同使用 类中全局日期处理上文方式的处理方法，如果需要注入多个日期，需要分别填写@DateTimeFormat，因此我们可以尝试复用日期格式 日期的显示处理可以直接格式化日期并返回String如果想在页面上自定义样式，需要使用JSTL，步骤如下 添加依赖 在页面上导入标签库 使用标签显示数据 SpringMVC执行分析关于annotation-drivern会自动注册以下两个bean DefaultAnnotationHandlerMapping解析服务器端资源地址，即地址映射器 AnnotationMethodHandlerAdapter构建对象，即处理器适配器 为什么资源放在WEB-INF目录下该目录下资源对外不可直接访问 拦截器开发与应用针对请求和响应进行的额外的处理，可以添加预处理、后处理和最终处理 处理流程：ruquest-&gt;preHandle()-&gt;处理器-&gt;postHandle()-&gt;afterCompletion()-&gt;response preHandle():在请求被处理时进行操作 postHandle():在请求被处理，但结果没渲染之前进行操作 afterCompletion():在请求响应结束后进行善后 实现方式 继承父类HandlerInterceptorAdapter 实现接口HandlerInterceptor，推荐使用该方式 实现步骤 在springMVC.xml中注册 开发拦截器 51"},{"title":"网络协议分层与典型协议剖析","date":"2023-04-05T07:53:43.000Z","url":"/2023/04/05/Protocal/","categories":[[" ",""]],"content":"喔，这不是常见八股吗 OSI是一个开放性的通信互联参考模型，具有7层结构，是一个理论模型TCP&#x2F;IP是当前互联网使用最广泛的模型五层模型是基于OSI与TCP&#x2F;IP衍生出的模型这三种模型的层次划分的对应关系如下：以OSI为例，分析每一层的功能 应用层为应用程序提供服务典型应用：HTTP&#x2F;FTP&#x2F;NFS&#x2F;SMTP等数据单元被称为：报文 表示层数据格式的转化和数据加密数据单元被称为：报文 会话层建立、管理和维护会话典型应用：SSL&#x2F;TLS数据单元被称为：报文 传输层建立、管理和维护端到端的连接运行：TCP&#x2F;UDP数据单元被称为：数据报 网络层IP选址与路由选择运行协议：IP&#x2F;IPv6&#x2F;ICMP数据单元被称为：数据包 数据链路层提供介质访问和链路管理典型协议：L2TP&#x2F;ARP数据单元被称为：帧 物理层信号传输数据单元：比特"},{"title":"C++中的四种智能指针","date":"2023-04-03T12:37:45.000Z","url":"/2023/04/03/smart-pointer/","categories":[[" ",""]],"content":"一般来说，C++中一共有4种智能指针，包括引入于C++98的auto_ptr，以及引入于C++11的unique_ptr&#x2F;shared_ptr&#x2F;weak_ptr auto_ptr：源自于C++98的老大哥 信息 说明 引入于 C++98 定义于 &lt;memory&gt; 优点 当指针对象被销毁时，它所管理的对象也会自动被delete掉 缺点 让我们在下面慢慢说 创建方法 auto_ptr ap(new string(“this is an auto_ptr”)); 支持 拷贝构造，有参构造，无参构造 开始慢慢说吧 unique_ptr：auto_ptr的优秀继承者 信息 说明 引入于 C++11 定义于 &lt;memory&gt; 优点 相对于auto_ptr来说，更加安全 创建方法 unique_ptr ap(new string(“this is an unique_ptr”)); 支持 有参构造，无参构造,拷贝构造 在auto_ptr中，虽然也有所有权的定义，但拷贝构造时不会发生所有权的转移，同一个对象仍然可以由多个不同的auto_ptr共享，因此也就造成了同一片内存空间可能被多次释放&#x2F;释放后调用，调用空指针等UB类问题但对在unique_ptr中，加强了所有权，一个对象只可以由一个unique_ptr进行独享，所有权可以被释放，可以被转移，但绝不能被共享，因此弥补了auto_ptr的一些缺陷 shared_ptr：允许多个指针指向同一个对象 信息 说明 引入于 C++11 定义于 C++11后：&lt;memory&gt; C++11前：Boost库 优点 相对于unique_ptr来说，允许多指针指向同一对象，且安全 创建方法 shared_ptr sp(new string(“this is an unique_ptr”)); 支持 有参构造，无参构造，拷贝构造 在shared_ptr中，引入了”计数器”这一概念，当多个指针指向同一个对象时，这些指针共享同一个计数器，记录着改对象被引用的次数，当指针被销毁时，计数器会同步减少，当计数器减少到0时，该对象会被自动销毁但是注意，shared_ptr在指针是线程不安全的，因此在涉及到修改等操作时需要加锁(mutex) weak_ptr：和shared_ptr通力合作的亲密友指针（其实也不能说是个智能指针） 信息 说明 引入于 C++11 定义于 C++11后：&lt;memory&gt; C++11前：Boost库 优点 相对于unique_ptr来说，允许多指针指向同一对象，且安全 创建方法 shared_ptr sp(new string(“this is an unique_ptr”)); 支持 无参构造，有参构造，拷贝构造 特性 可以弱引用shared_ptr且不会增加计数器计数 该指针被设计成和shared_ptr共同使用，可以用于观测shared_ptr目前的状态或对shared_ptr指向的对象进行一些操作 那么这个指针的意义是什么？难道只是一个观星者吗？答案：解除循环依赖问题假设我们现在有两个对象A和B 在我们实例化A类和B类，并调用两个set方法注入A和B的成员指针后，A和B构成了循环依赖，这两个类会因为该依赖关系而都无法被自动销毁（永远都会因为对方的成员指针而导致计数器不为0），此时我们可以调用weak_ptr获取实例之后进行手动销毁注意：通过weak_ptr的成员函数lock()获取的是其引用的shared_ptr所指向的对象，并不是副本或拷贝"},{"title":"关于linux编程的一些基础知识","date":"2023-04-02T03:45:43.000Z","url":"/2023/04/02/gcc/","categories":[[" ",""]],"content":"用了这么久了，我竟然还不知道它是怎么跑起来的QAQ gcc的常用选项 选项 作用 备注 -E 预处理指定文件 -S 编译指定的源文件 -c 编译、汇编但不链接 -o [file1] [file2] 将file2编译成可执行文件file1 -I 指定include的搜索目录 -g 编译时生成调试信息 -D 程序编译的时候指定一个宏 -w 不生成任何警告信息 -Wall 生成所有警告信息 -On n&#x3D;[0,3] 优化级别 -l 指定编译时使用的库 -L 指定编译的时候搜索的库路径 -fPIC&#x2F;fpic 生成与位置无关的代码 -shared 生成共享目标文件 -std 指定语言标准 如-std&#x3D;c99 gcc工作流程原代码(.h&#x2F;.c&#x2F;.cpp) –预处理器–&gt; 预处理后源代码 –编译器–&gt; 汇编代码(.s) –汇编器–&gt; (启动代码、目标代码、库代码、其他目标代码) –链接器–&gt; 可执行程序 静态库和动态库静态库 注意：库文件需要和对应的头文件一起使用 命名规则 linux平台前缀：lib后缀：.a windows平台前缀：lib后缀：.lib 如何打包将写好的源码通过gcc获得.o文件使用ar工具插入 ar rcs libxxx.a xxx.o,xxx.o(需要被打包的a文件，可以是多个)r:将文件插入备存文件c:简历备存文件s:索引获得libxxx.a文件 如何使用自定义静态库答：在编译时指定扫描路径gcc xxx.c -o app -I ..&#x2F;include&#x2F; -l calc -L .&#x2F;lib小小的回忆一下之前的知识：-I 指定include的搜索目录-l 指定编译的时候使用的库-L 指定编译的时候搜索的库的路径linux严格区分大小写 动态库命名规则 linux平台前缀：lib后缀：.so windows平台前缀：lib后缀：.dll 如何打包： gcc得到.o文件，即和位置无关的代码gcc -c -fpic&#x2F;-fPIC a.c b.c gcc 得到动态库gcc -shared a.o b.o -o libxxx.so从而获得libxxx.so文件 如何使用自定义动态库参照自定义静态库完成编译链接 动态库和静态库的区别是什么？静态库：代码会被打包到可执行程序中动态库：代码不会被打包到可执行程序中因此，如果一个程序使用了动态库，在其启动的时候，动态库会被动态加载到内存之中，可以通过”ldd [file]”命令检查动态库依赖关系 如何定位动态库?使用系统的动态载入器来获取绝对路径现在主流的linux动态库加载器为ld-linux.so 如何将自己的动态库添加到加载器内？ 会话级配置：直接执行export LD_LIBRARY_PATH&#x3D;$LD_LIBRARY_PATH:[new path]解释：在LD_LIBRARY_PATH内追加新动态库路径，$[]为对原有系统变量的引用缺点：在终端关闭后即失效 用户级配置：在~&#x2F;.bachrc文件中加入export LD_LIBRARY_PATH&#x3D;$LD_LIBRARY_PATH:[new path]加入后使用source .bachrc进行更新 系统级配置在&#x2F;etc&#x2F;profile中加入export LD_LIBRARY_PATH&#x3D;$LD_LIBRARY_PATH:[new path]加入后使用source &#x2F;etc&#x2F;profile进行更新(不需要sudo) 动态库和静态库的优缺点静态库优点： 静态库被打包进程序，加载速度较快 发布时直接发布程序即可，移植工作量小缺点： 占用空间较大 更新、部署、发布比较麻烦，更改其中一个文件需要重新发布整个程序 动态库优点： 可以实现进程间资源共享 更新、部署、发布简单 可以控制加载时间，使用到再加载缺点： 相对于静态库，加载速度慢 发布程序时需要提供其依赖的动态库 Makefile作用：对于一个大的项目来说，他们的依赖关系非常复杂，如果使用单挑命令进行编译，时候维护难度会相对较大，使用makefile文件，可以指定文件的编译顺序、编译选项，同时，还可以实现自动化编译，在对代码进行更改后执行make命令就可以完成编译文件名：makefile&#x2F;Makefile 规则 一个makefile文件中可以有一个或者多个规则目标…:依赖…&amp;nbsp&amp;nbsp命令….（注意制表符）目标：最终需要生成的文件依赖：生成目标所需要的文件或目标命令:通过执行命令对依赖操作生成目标(必须有缩进) 一般来说，makefile的其他规则都是为了第一条规则服务的 工作原理： 命令在执行前，会检查规则中的依赖是否存在 如果存在，则执行 如果不存在，会向下检查其他规则，如果找到了，执行 检测更新，在执行规则中的命令时，会比较目标和依赖文件的时间 如果依赖的(最后修改)时间比目标的时间晚，则需要重新生成目标 如果依赖的时间比目标的时间早，对应规则的命令不会被执行 变量自定义变量[name]&#x3D;[value] 预定义变量AR 归档维护程序的名称，默认为arCC c的编译器的名称，默认为gcccxx c++的编译器的名称$@ 目标的完整名称$&lt; 第一个依赖文件的名称$^ 所有的依赖文件…….还有很多，这里只列举常用的 获取变量的值$(变量名) 函数$(函数名 参数)比如：$(wildcatd PATTERN)…功能：获取指定目录下指定类型的文件列表参数：pattern指的是某个或多个目录下某种类型的文件返回值：得到一个文件列表，文件名之间用空格间隔示例：$(wildcard .c .&#x2F;sub&#x2F;.c) 获取当前目录与同级sub目录下的所有*.c文件名$（patsubst,&lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;）查找&lt;text&gt;中的单词是否符合&lt;pattern&gt;模式，如果匹配的话，用&lt;replacement&gt;替换示例：$(patsubst %.c,%.o,x.c bar.c)返回值格式：x.o bar.o GDBgdb是由gnu组织提供的调试工具，和gcc配套组成了一套完整的开发环境主要协助完成如下功能： 按照自定义的要求运行程序 在指定的断电处暂停程序运行 在程序暂停运行时检查内部运行状态 可以改正程序 准备工作 编译时加上调试选项’-g’ 调试选项的作用：在可执行文件中加入源代码的信息，使可执行文件的指令和源代码的行数建立联系，但并不嵌入源文件，因此必须保证gdb可以找到源文件 编译时加上’-Wall’ 打开所有warning 关闭编译器优化(-o) 开始工作使用命令gdb进入gdb环境 GDB常用命令 启动和退出gdb [name]quit 设置属性并获取set [name] [value]show [name] 查看当前文件代码list&#x2F;l [文件名]:[行号&#x2F;函数名]若留空文件名，只查看当前文件使用show list&#x2F;listsize 可以查看当前一次展示的行数使用set list&#x2F;listsize [number]可以修改每次显示的行数(defaule 10) 设置断点break&#x2F;b [文件名]:[行号&#x2F;函数名]这样设置好的是普通断点break&#x2F;b [文件名]:[行号&#x2F;函数名] [条件]这样可以在某一行设置条件断点(一般用于循环)例： b test.cpp:9 if i&#x3D;&#x3D;3 查看断点info&#x2F;i break&#x2F;b(是一个整体，比如info break这样输入) 删除断点d&#x2F;del&#x2F;delete [num]注意是断点编号不是断点所在行数，可以使用info查看断点编号 设置断点有效&#x2F;无效enable&#x2F;disable [num] gdb调试命令 运行程序start 开始运行，但停留在第一行run 开始运行，直到遇到可以停顿的断点 继续运行，到下一个断点停continue&#x2F;c 向下执行一行代码(不会进入函数体)next&#x2F;n 操作变量print&#x2F;p [name] 打印变量的值ptype [name] 打印变量的类型 向下单步调试step&#x2F;s 向下运行一行finish 跳出当前函数体 自动变量操作display [name] 每次运行到断点处时自动打印指定变量的值undisplay [name]info&#x2F;i [display&#x2F;undisplay] [num] 其他变量操作set var [name]&#x3D;[value]until(跳出循环) 小tip在断点所在行停留时，该行代码并不会被执行，继续运行代码后才会执行该行代码 文件IOC语言中的文件IO：使用fopen或其他函数打开文件，返回值FILE *fp为一个指针，由三个部分组成 文件描述符[整型值]： 索引对应的磁盘文件 文件读写指针：读写文件过程中指针的实际位置(内存) I&#x2F;O缓存区[内存地址]：通过寻址找到对应的内存块(默认为8192byte)缓存区的意义：软件直接写入缓存区，当( 1.缓存区达到最大容量时 2.调用fflush 3.正常关闭文件 )时，缓冲区内容会被写入磁盘，可以提高系统运行效率 C语言IO和linux系统IO的关系程序&lt;-&gt;C标准IO库(缓冲区在此)&lt;–系统内核IO–&gt;磁盘 虚拟地址空间每个进程都会被分配一个虚拟地址空间，里面的数据会通过cpu的MMU(内存管理单元)映射到物理内存中，这段空间按照操作者被分为内核区和用户区 用户区 受保护的地址(0-4K) .text 代码段 .data 已初始化的全局变量 .bss 未初始化的全局变量 堆空间(较大) 共享库(动态链接库) 栈空间(较小) 命令行参数 char* argv[] 环境变量 内核区即Linux kernel，不可以由程序进行操作，之可以通过程序调用系统API，从而间接更改内核数据 内存管理 进程管理 设备驱动管理 VFS虚拟文件系统 文件描述符与系统APIopen&amp;close在上文提到的”内核区”中，有一个模块叫做PCB-进程控制块，指向文件描述符表每打开一个新文件，就占用空闲的最小的文件描述符系统IO函数和标准C库存在一定的对应关系 read&amp;write lseek函数 stat&#x2F;lstat 文件属性操作函数 目录操作函数 目录遍历函数 关于dirent结构体： 成员类型 成员名 说明 ino_t d_ino 进入点的inode off_t d_off; 目录文件开头到本文件的位移 unsigned short int d_reclen; d_name的长度 usigned char d_type; 所指的文件类型 char d_name[256]; 文件名 文件描述符相关函数"},{"title":"Redis","date":"2023-03-21T09:47:19.000Z","url":"/2023/03/21/Redis/","categories":[[" ",""]],"content":"喔，R！ Redis入门 redis是键值数据库(非关系型&#x2F;K-V&#x2F;NoSql数据库) 因此，可以用复杂数据类型包装value来存储复杂数据 Remote Dictionary Server-RE DI S NoSQL特性 非结构化（通过K-V） 无关联的（智能通过业务逻辑维护表间关系） 非SQL（没有通用的语法标准） 无事务，BASE理论（基本可用（Basically Available）、软状态（Soft-state）、最终一致性（Eventually Consistency）），难以满足ACID 内存存储 水平扩展 适用场景： 数据结构不固定 对一致性、安全性要求不高 对性能要求较高 Redis特征 K-V，支持数据结构较多 单线程，每个命令具备原子性 低延迟、速度快（基于内存、IO多路复用，编码良好） 支持数据持久化 支持主从集群、分片集群 支持多语言客户端 常用命令 Expire Key [time(s)] 设置某键有效期（-1为永久存在，-2为已经过期） TTL Key 查看某键剩余有效期 Keys Model 查看符合模板的所有key Del Key 删除一个指定的key Exists Key 查看key是否存在 Redis数据结构 Name Example String hello Hash {name:”jack”,age:21} List [A-&gt;B-&gt;C-&gt;D] Set {A,B,C} SortedSet {A:1,B:2,C:3} GEO {A:(120.3,36.2)} BitMap 11011 HyperLog 11011 Redis的层级格式key允许使用多个词条形成层级结构，多个词条之间使用”:”隔开层级在redis内部是真实存在的，不是通过业务分割的 String类型字符串类型，可以根据内容不同分为三类（仍然为字符串类型） string 普通字符串 int 整数 float 浮点数其中int和float可以进行自加&#x2F;自减操作如果要让一个key的value有很多属性，需要打包成json 常见命令： set 设置键值对 get 获得键值对 mset 批量设置键值对 mget 批量获得键值对 incr 让一个整型的key自增1 incrby 让一个整型的key自增并指定步长 incrbyfloat 让一个浮点型的key自增并指定步长 存在decr，但是一般都用incr加负数步长 setnx 添加一个键值对，前提是不存在，否则不执行 setex 添加键值对并指定有效期键值对有效期的场景：获取短信验证码&#x2F;二维码登录等 Hash类型如果要让一个key的value有很多属性，可以分别存储KEY (key1 value1 key2 value2…) 常见命令 hset key field value 参考string hget 参考string hmset 参考string hmset 参考string（4.0后已被禁用） hgetall 获取一个key中的所有field和value hkeys 获取一个key中的所有field hvals 获取一个key中的所有value hincrby 让一个hash的key字段自增并指定步长（只能指定integer） hsetnx 添加一个hash类型的key的field值，前提是不存在，否则不执行 List类型可以看作是双向链表，支持正向检索和反向检索特征： 有序 元素可以重复 插入和删除较快 查询速度一般 常见命令： (L&#x2F;R)PUSH key element… 向链表(左&#x2F;右)侧插入一个元素 (L&#x2F;R)POP key 移除并返回(左&#x2F;右)侧的第一个元素，没有则返回nil LRANGE key star end 返回一段角标范围内的所有元素 B(L&#x2F;R)POP 与普通类似，没有的时候会等待指定时间，不会返回nil Set类型底层类似Java中的HashMap 无序 数据不可重复 查找较快 支持交&#x2F;并&#x2F;差等功能 常用命令： SADD key member 添加一个或多个元素 SREM key member 移除指定元素 SCARD key 返回元素个数 SISMEMBET key member 判断是否存在 SMSMBERS 获取set中的所有元素 SINTER set1 set2 求交集 SDIFF set1 set2 求差集 SUNION set1 set2 求并集 SortedSet 可排序集合底层数据结构为跳表+hash表每一个元素都带有score属性，根据score进行排序 有序 数据不重复 查询较快 常用命令：SortedSet的常见命令有: ZADD key score member:添加元素，如果已经存在则更新其score值在一个命令中添加多个元素时： ZREM key member:删除集合中的一个指定元素 ZSCORE key member:获取集合中的指定元素的score值 ZRANK key member:获取集合中的指定元素的排名 ZCARD key:获取集合中的元素个数 ZCOUNT key min max:统计score值在给定范围内的所有元素的个数 ZINCRBY key increment member: 让集合中的指定元素自增，步长为指定的increment值 ZRANGE key min max:按照score排序后，获取指定排名范围内的元素 计数器从0开始 ZRANGEBYSCORE key min max:按照score排序后，获取指定score范围内的元素 ZDIFF、ZINTER、ZUNION:求差集、交集、并集 所有的查询默认为升序，如果需要降序则将命令改为ZREVxxx"},{"title":"STL容器简介","date":"2023-03-17T09:03:34.000Z","url":"/2023/03/17/STL/","categories":[[" ",""]],"content":"STL标准库中一共有 7 种序列容器， 4 种关联容器， 4 种无序关联容器(C++11新增) 首先明确定义：什么是容器？ 容器是存储其他对象的对象 容器贯彻了C++泛型编程的思想，结合OOP理念 底层实现：类与模板 忘记了可以来开天辟地（bushi）C++笔记 注意，在不加其他限制措施的情况下，任何STL容器都不提供任何强度的线程安全保证 序列容器序列的基本方法： 方法 含义 备注 insert() 插入一个对象 erase() 删除一个对象 需要传入迭代器 clear() 清空序列内容 元素按照线性顺序排列 vector 动态数组 支持随机访问且速度较快 可以根据数组长度动态申请内存大小 在尾部添加和删除元素的时候是固定时间复杂度 在头部添加和删除元素的时候是线性时间复杂度 可反转 deque 双端队列 支持随机访问 在首位添加或删除元素的时候是固定时间复杂度（效率低于vector） 可反转 list 双向链表 不支持随机访问 任意插入或删除都是线性时间复杂度 存在sort成员函数 forward 单向链表 不支持随机访问 不可反转 在C++11后提供 queue 队列 性质如其名 为deque的封装 priority_queue pq(greater) 优先队列 底层使用堆实现 队列内数据有序 性质如其名 stack 栈 性质如其名 为deque的封装 关联容器 保存k-v数据 元素保存有序 查询性能和插入性能较稳定，一般为log级 一般底层使用树存储 set 集合容器 没有kv，k就是v 可反转 可排序，默认升序 键唯一，不可重复 提供交并差运算(略复杂) multiset 多重集合 在set的基础上允许重复 map 映射 k-v结构，键不可重复 查询和插入都是稳定的log(n) 可反转，有排序 multimap 多重映射 在map的基础上允许重复 无序关联容器（哈希容器） 保存k-v数据 元素保存无序 查询与插入性能优异，一般为O(1) 遍历性能较差 底层使用哈希存储 unordered_map 哈希组织的map unordered_map是如何解决哈希冲突的？首先明确 unordered_map底层采用的是开链法，即，如果发生哈希冲突，会在当前节点初始化一链表，并将当前数据插在链表的头部，因此每一次插入的时间复杂度仍然为O(1)。在极限情况下，哈希表会退化为链表，此时引入概念：负载因子(load_factor)：hashtable的元素个数和hashtable的桶数间的比值即load_factor&#x3D;(float)map.size()&#x2F;map.buck_count();最大负载因子(max_load_factor):负载因子的上限当load_factor&gt;&#x3D;max_load_factor(调用max_load_factor方法可以得最大负载因子默认为1)时，发生rehash unordered_set 哈希组织的set unordered_multimap 哈希组织的mulitmap，key可重复出现 unordered_multiset 哈希组织的multiset，key可重复出现 "},{"title":"linux","date":"2023-02-27T12:16:01.000Z","url":"/2023/02/27/linux/","categories":[[" ",""]],"content":"我是谁，我在哪，我在干什么 linux的目录结构 linux没有盘符的概念，只有一个 根目录 &#x2F;，所有的文件都在&#x2F;下面 linux命令入门基本格式：command [-options] [parameter] ls命令查看当前目录下内容(文件&amp;&amp;文件夹)ls [-a -l -h] [path]选项列表： -a 列出全部文件（包括隐藏的文件&#x2F;文件夹） -l 以列表方式展示文件详细信息 -h 以易于阅读的形式列出文件大小若不加path参数则展示当前目录下内容注意： linux启动的时候默认会加载当前用户的个人目录，即&#x2F;home&#x2F;${username} 以.为开头的文件会被认为是隐藏的文件 如果不加-h，文件大小默认单位为B，加上后会被优化为K,G等更大的单位 cd&#x2F;pwd命令"},{"title":"maven","date":"2023-02-21T06:45:25.000Z","url":"/2023/02/21/maven%E7%AC%94%E8%AE%B0/","categories":[[" ",""]],"content":"喔，填坑呢在这 组成 坐标 groupId 隶属组织名称 artifactId 当前项目名称 version 当前版本号 packaging 打包方式（默认为jar） 作用：唯一定位该资源，查找、下载并使用资源 配置 环境变量MAVEN_HOME 可以配置settings.xml（全局生效），也可以配置pom.xml（对当前项目生效） 本地仓库配置… 配置镜像仓库（加速下载，常用阿里云仓库）… 依赖 项目可以依赖项目 项目可以依赖现成的包 依赖中存在的问题： 路径优先:当依赖中出现相同的资源时，层级越深，优先级越低，层级越浅，优先级越高 声明优先:当资源在相同层级被依赖时，配置顺序靠前的覆盖配置顺序靠后的 特殊优先:当同级配置了相同资源的不同版本，后配置的覆盖先配置的 可选依赖 场景：不希望别人知道我用过这个依赖 true 效果：当前项目使用该依赖，但依赖该项目的项目不自动引用该依赖 排除依赖 场景：不希望使用某依赖 在一个dependency里写： 效果：若当前项目排除了依赖项目的A依赖，则该A依赖不会被当前应用所依赖 依赖范围：注意：依赖范围具有传递性 scope 主代码 测试代码 打包 compile(默认) 1 1 1 test 0 1 0 provided 1 1 0 runtime 0 0 1 生命周期与插件clean 清理 pre-clean clean post-cleandefault 核心工作（编译、测试、打包、部署） site 产生报告 pre- site post-site site-deploy 插件：与生命周期相绑定或者可以说maven的每一个生命周期都是利用插件来实现的 引入引入方式同依赖，只不过把dependency改成plubins&#x2F;plugin&lt;groupId&gt;…&lt;&#x2F;groupId&gt;&lt;artifactId&gt;….&lt;&#x2F;artifactId&gt;&lt;version&gt;…&lt;&#x2F;version&gt; 目标设置&lt;executions&gt;…&lt;&#x2F;executions&gt;下层：指令&lt;&#x2F;goal&gt;运行阶段&lt;&#x2F;phase&gt;即为在哪个生命周期中执行该插件 分模块开发与设计总目标：将程序拆装成不同模块，利用接口通信 （不是java的接口）controller 控制层service 业务层dao 持久层pojo 展示层 聚合依赖用一个模块来管理其他模块 设置聚合模块打包方式为pom &lt;modules&gt;被聚合的工程列表&lt;&#x2F;modules&gt; 继承 模块依赖关系维护 子模块可以声明需要依赖，但是不限定版本，若出现版本冲突则会难以解决 解决方案： 在聚合模块中声明所有的依赖 在子模块中声明&lt;parent&gt;工件ID&#x2F;版本&#x2F;GroupId….&lt;&#x2F;parent&gt; 子工程在设计dependency时不需要写version继承的作用：子工程中沿用父工程的依赖配置 属性定义自定义属性 版本管理 关于版本号命名的小常识 snapshot 开发过程中，为方便合作或解决依赖等，输出的临时性版本，会随着开发的进展不断更新，更新周期较短 release 经过测试后，团队对外发布的，运行较为稳定的版本，更新周期较长 关于版本号的一些约定：&lt;主版本&gt;&lt;次版本&gt;&lt;增量版本&gt;&lt;里程碑版本&gt; 如：5.1.13-Release 多环境开发配置-不需逐个更改文件即可兼容（生产环境&#x2F;开发环境&#x2F;测试环境……） 执行特定环境方法：mvn -P [环境名称] 跳过测试 常用场景： 模块功能未开发（完毕） 单个功能更新导致其他功能失效 快速打包 方式 在maven配置窗口跳过 mvn -D skipTests 在pom中配置测试插件(maven-surefire-plugin)，设置&lt;skipTests&gt;true&lt;&#x2F;skipTests&gt;(不建议使用) 只使用部分用例测试 在测试插件(maven-surefire-plugin)的configuration中，设置include-对应的测试用例(.java) "},{"title":"Spring","date":"2023-02-05T13:46:09.000Z","url":"/2023/02/05/Spring%E7%AC%94%E8%AE%B0/","categories":[[" ",""]],"content":"Spring框架笔记 开闭原则（Open Cloce Protocal, OCP）：软件应对扩展开放，对修改关闭依赖倒转原则（Dependency Inversion Principle, DIP）： 控制反转 编程思想（Inversion of Control, IoC） Spring框架 Spring的配置文件 Spring容器的使用 启动Log4j2日志框架 * 创建xml配置文件 * 在项目内记录日志信息 * 创建日志记录器对象 set注入详解 命名空间注入 util命名空间实现配置复用 基于XML的自动装配 引入外部properties文件 bean的作用域 bean的实例化 Bean的生命周期 Bean的循环依赖 spring仅可以自动处理set注入&#x2F;singleton情况下的循环依赖问题 构造注入&#x2F;(singleton&#x2F;prototype&#x2F;Others)情况下__无法解决__原理：调用无参构造方法实例化对象（此时即曝光该Bean对象），然后使用set注入 Bean的三级缓存private final Map&lt;String,Object&gt; singletonObjects 一级缓存private final Map&lt;String,Object&gt; earlysingletonObjects 二级缓存private final Map&lt;String,ObjectFactory&lt;?&gt;&gt; singletonFactories 三级缓存(该map集合即被称为缓存)key为bean的idvalue:一级缓存：经过注入后完整的bean对象二级缓存：已经被实例化，但是还没有赋值属性的bean对象三级缓存：单例工厂对象 Spring IoC 注解式开发目的：简化XML配置使用方式：在配置文件中添加aop依赖，配置context命名空间，配置扫描，在类上只用注解 注解的开发 用于bean的注解 Component Repository Controller Service 如何在spring中使用注解 加入aop的依赖 添加context命名空间 指定扫描包 使用注解即可 选择性实例化bean 方案1：&lt;context:component-scan base-package&#x3D;”被扫描包” use-default-filters&#x3D;”false”&#x2F;&gt;false时让该包下所有的带有声明Bean的注解全部失效，Beans集体去世在此标签间可以加入（记得改为双标签）：&lt;context:include-filter type&#x3D;”annotation” expression&#x3D;”注解的完整类名，如org.springframework.stereotype.Repository”&gt;让带有某注解的失效 方案2：&lt;context:component-scan base-package&#x3D;”被扫描包” use-default-filters&#x3D;”true”&#x2F;&gt;true时让该包下所有的带有声明Bean的注解全部生效&lt;context:exclude-filter type&#x3D;”annotation”,expression&#x3D;”注解的完整类名”&gt;让带有某注解的Bean生效 负责注入的注解 @Value指定bean内参数值，只可以注入简单类型，可以在属性上，可以用在set方法上，也可以用在构造方法的形参上 @Autowired不需要指定任何属性，直接使用即可但对应类型的类只可以有一个实例对象，即便是接口实现&#x2F;类的继承也会引起冲突默认为byType，可以使用在构造方法、方法、形参、属性、注解上UserDao-&gt;(UserDaoImplForPgSQL&#x2F;UserDaoImplForMySQL)，这种情况如果AutoWired注解一个UserDao对象就会引起注入冲突如果直接在代码中指定对象类型为xxxForMySQL这种会违反开闭原则哦可以注入非简单类型（ByName&#x2F;ByType）解决方法：使用byName，@Autowired和Qualifier联合使用，在Qualifier中指定名字 @Qualifier指定注入类名字，和Autowired搭配使用 @Resource完成非简单类型注入，是JDK提供的注解默认byName，未指定时使用属性名作为name，如果还找不到就byType装配可以使用在属性和setter方法上一般推荐使用Resource替代Autowired引用注解： 全注解式开发使用一个类代替配置文件 AOP-面向切面编程AOP：Aspect Orinted Programming，是OOP的补充和延申可以将和业务逻辑无关的、可复用的代码（即交叉业务）抽离出来，，形成组件在程序的特定地点（切面）插入如果不采用AOP，可能导致的问题有： 部分交叉业务代码在多个业务中反复出现，并且和业务代码掺杂，修改难度较大 代码者难以专注于核心代码的编写优点有： 开发者可以专注于业务逻辑 交叉业务易维护 代码复用性更强 AOP的常见术语 连接点(JoinPoint)：程序可以织入切面的位置 切点(Pointcut)：被织入切面的方法 通知(Advice)：又被称作增强，就是具体要织入的代码体包括( 前置:仅在Pointcut前 @Before, 后置:仅在Pointcut后 @AfterReturning, 环绕:在Pointcut前后 @Around, 异常:Pointcut位于catch @AfterThrowing, 最终:Pointcut位于finally语句块 @After )通知; 切面(Aspect):切点+通知即切面 织入(Weaving):把通知应用到目标位置的过程 代理对象(Proxy):一个目标对象被织入通知后产生的新对象 目标对象(Target):被织入通知的对象 切点表达式用于定义通知往哪些方法上切入基本格式： 必须精确到类 访问权限： 如果是public就只包括公开的方法 返回值类型： 必填，可以填*表示返回类型任意 全限定类型: 可选 填写..表示当前包和子包下所有的类 省略表示所有类 方法名 必填 表示所有方法 set表示所有以set开始的方法 形式参数列表 必填 (..,类型个数随意),(,没有参数的方法),(,有一个参数的方法),(,String)第一个参数随意，第二个String 异常 可选 省略时表示所有类型 例子： 使用Spring的AOP方式1：Spring+AspectJ-注解方式方式2：Spring+AspectJ-XML方式方式3：Spring-注解方式引入依赖： 使用注解实现AOP定义切面类，使用注解指定通知类型，括号内指定切点（可以使用切点表达式，也可以同一切点） 将切面纳入Spring管理（通过注解&#x2F;XML） 开启自动代理 通用切点 连接点在通知可以传入ProceedingJoinPoint类型的对象，即连接点，可以直接调用其成员方法 .proceed() 运行 .getSignature() 获取信息 全注解开发之前提过一次，但是当时只有IoC全注解开发 基于注解的实现 AOP编程式事务解决方案-&gt;满足ACID特性解决方案：利用AOP Spring对事务的支持(声明式事务)前置知识：锁和隔离"},{"title":"并发控制","date":"2023-02-05T02:12:25.000Z","url":"/2023/02/05/SQL-lock/","categories":[[" ",""]],"content":"锁、事务、隔离 首先明确MySQL的最基础架构客户端&#x2F;连接–&gt;链接线程处理–&gt;解析器–&gt;查询缓存–&gt;优化器–&gt;存储引擎–&gt;数据 对于客户端&#x2F;连接，需要明确，每一个客户端连接都会独立的拥有一个线程，所以当多个查询再同一时刻读写数据时，就容易产生冲突，为了避免冲突发生，我们需要做好并发控制，保证一个线程的运行不会对其他线程的运行产生预料外的影响。 锁读写锁多个线程同时读取统一数据显然不会发生问题，但如果多个线程同时有读有写，就会造成两个线程对于同一个语句读取到的数据不一致的问题，因此，为了安全起见，我们要为数据加锁 共享锁&#x2F;读锁&#x2F;乐观锁&#x2F;协同锁被锁定的数据不可以被其他线程重复写入，但可以被其他线程读取 排他锁&#x2F;写锁&#x2F;悲观锁&#x2F;强制锁被锁定的数据不可以被其他线程重复写入，也不可以被其他线程读取 锁粒度如果被锁定的数据过多，则会造成其他同样需要该数据的线程阻塞的情况，一般来说，在MySQL中，存在两种粒度 表锁读取时会锁定整张表 行级锁读取时只会锁定行锁的实现位于存储引擎层，因此存储引擎之上的层并不会知晓锁的情况和概念 事务事务的基本性质（ACID） 原子性(Atomicity)事务被视为不可分割的工作单元，一个事务的操作要不全部执行，要不全部不执行，事务不可以被再次切分 一致性(Consistency)数据库永远保持一致性，如果事务没有被提交，那么其所做的修改也不会被保存到数据库中 隔离性(Isolation)事务之间是不可见的，即正在执行（或执行完尚未提交）的事务并不会对其他事务读取到的结果造成任何影响 持久性(Durability)一旦事务提交，则其所做的一切修改都会被永久保存并对外可见 隔离级别隔离性的实现也存在级别差异，在SQL中规定了四种隔离级别，较低级别的隔离往往可以获得更高的性能以下为四种隔离级别： 未提交读（READ UNCOMMITTED）事务中的修改即使没有提交也对其他事务可见 提交读（READ COMMITTED）事务的修改只有提交后才对其他事务可见，这也是大多数数据库系统的默认隔离级别 可重复读（REPEATABLE READ）此级别是MySQL的默认事务隔离级别，采用多版本并发控制，避免了幻读的问题 可串行化（SERIALIZABLE）强制事务串行执行，会在读取的每一行数据都上锁，因此会导致大量的超时和锁争用问题 脏读：读取到其他事务尚未提交的数据 不可重复读：一个事务读取到另一个事务提交的数据，即同一个事务对于同一组数据读取到的结果不一致 幻读：某个事务在读取某一范围的记录时，另一个事务又在该范围插图了新的记录，当该事务再次读取时，会发生幻行 加锁读：读取必加锁不可重复读和幻读：不可重复读强调前后同一条数据的结果不一致，幻读强调数据多出现多行，即”幻行” "},{"title":"About-2023","date":"2023-02-01T14:18:58.000Z","url":"/2023/02/01/About-2023/","categories":[[" ",""]],"content":"无人时别理亲疏 二人暂借星火 这分钟仿似伴侣 至少并非孤独过 这个世界-孙燕姿2023才刚刚开始，歌曲可能会随每月心情而更改;-) 今年更是全新开坑的一年！我决定年初就开始写总结！ 一月份 双板滑雪入门之在中级道被鱼雷创飞！ 从0开始的python生活 二月份 为什么周围人都这么卷啊 Spring！ 从0开始的实习生活 得到又失去，相遇却别离，或许重逢，或许再而不见 开学🌶 三月份 楞学C++ 周围人都好卷啊 找不到实习了嘤嘤嘤 四月份 放弃找实习，专心学技术 感觉好像忙忙碌碌的什么也没干，这个月就过去了 五月份 关于五一本来想学五天习但是看了四天车这件事 订车啦 "},{"title":"Sql基础知识","date":"2023-01-28T12:17:18.000Z","url":"/2023/01/28/pgsql/","categories":[[" ",""]],"content":"大二没好好学呜呜呜 SQL 备忘录 基本语句格式 select from where group by 按照一定规则分组，可以有多个参数 多参数时，若两参数的参照关系完全相同，会归为一类 多参数时，会按照设置的参数项目对结果进行分类 必须与聚合函数（count()\\sum()等）搭配使用，否则会报错 order by 按照一定规则排序 order by colomn [asc|desc] asc:Ascend 升序 desc:Descend 降序 关键字 distinct 保证结果（根据某一列&#x2F;多列）严格不相同 join 连接 见6 as 为某项数据设置别名，一般在存在复杂子查询时使用 exists 后接内层子查询，返回结果为Yes或No，若外层查询到的数据在内层中满足条件的出现过，则返回Yes limit 用在from后：可以设置搜索的偏移量，提升搜索效率，select * from table limit 起始行,向后偏移量（-1则搜索到表结尾） 用在where后：限制结果数量，搜索到指定数量的记录后即停止搜索，避免搜索全表 select * from table where colomn&#x3D;? limit 1 union 用在两个select整体之间，用来连接搜索结果，要求被连接的两个表拥有严格相似的结构 in&#x2F;not in 用于限制条件，可以限制搜索目标in(ans1,ans2,ans3……) like &amp;&amp; ilike 见7 having 过滤搜索结果，见8 内置函数 generate_series(start, stop, step),可以用于数字&#x2F;时间的序列生成，step可以为除了0以外的任何实数 row_number() over (order by colomn [asc|desc]) 对于某列的数据按照[升序|降序]生成序列，遇到相同数据不会生成重复序号 rank() over (order by colomn [asc|desc]) 对于某列的数据按照[升序|降序]生成序列，遇到相同数据会生成重复序号，相同的数据只占用一个名次 dense_rank() over (order by colomn [asc|desc]) 对于某列的数据按照[升序|降序]生成序列，遇到相同数据会生成重复序号，相同的数据占用多个名次 NTILE(number) over (order by colomn [asc|desc]) 对于某列的数据按照[升序|降序]生成序列，每个数字项出现number次 聚合函数 count sum 范式 1NF 数据是不可再分的 解决方法：拆数据项 2NF 在1NF的基础上，消除了非主属性对于码的部分函数依赖，即保证通过主键可以唯一确定该项每一列的值 解决方法：拆表 3NF 在2NF的基础上，消除了传递依赖，一个表中不可以存在任何非主属性可以被另一项非主属性唯一确定 解决方法：进一步拆表 表达式 case表达式 简单case表达式 连接 inner join left (outer) join right (outer) join full outer join粗浅的理解：先发生表结构拼接 join 中文 粗浅的理解 备注 inner join 内连接 A交B left (outer) join 左(外)连接 A并(A交B) B表中没有的内容留空 right (outer) join 右(外)连接 (A交B)并A A表中没有的内容留空 full outer join 全外连接 A并(A交B)并B AB中互相没有的留空，然后补齐在总表下方 A join B on 匹配条件仅保存符合匹配条件的数据库记录 通配符与模糊搜索 like &amp;&amp; ilike like在搜索时区分大小写 但ilike不区分 两个通配符 _ 占位通配符，该通配符出现的次数严格匹配目标的格式，如_0，则目标字串的第二位一定为0 % 不占位通配符，该通配符出现的地方不限制字符数字，可以为0-n个字符填充，如%0，此时目标串含有0则会被选中语句示例：select * from table where colomn like ‘%_00’ like可以用于复制一张表的结构 （不包含数据） create table table2(like table1) having的用法 区分having和where： where是直接在搜索的时候进行筛选，having是过滤搜索结果 执行顺序：where-→聚合函数-→having having后面可以使用聚合函数，但where不可以 "},{"title":"C++笔记","date":"2023-01-17T09:15:50.000Z","url":"/2023/01/17/C/","categories":[[" ",""]],"content":"有人查漏补缺，有人精卫填海，有人开天辟地(bushi 内存的分区模型代码区：存放函数体的二进制代码全局区：存放全局变量、静态变量、常量栈区：由编译器自动分配&#x2F;释放，存放函数参数和局部变量等堆区：由程序员分配和释放，若未释放则在程序结束时由操作系统回收 代码区的特点：共享（多次执行只需要一份代码即可），只读（防止意外修改）全局区的特点：数据在程序结束后由操作系统释放栈区的特点：保存在栈区的数据在函数执行完即自动释放堆区的特点：用new开辟，由程序员指定分配 引用（给变量起别名）,指向同一片内存空间意义：要求： 一定要初始化 一旦初始化了，就不可以更改了 参数传递 值传递 地址传递 引用传递 引用作函数返回值含义：如果一个函数的返回值是引用，那么这个函数可以作为左值 不要返回局部变量的引用 引用的本质：一个指针常量，指针不可以修改，但是指针指向的值可以修改由编译器完成（引用→指针常量）的过程常量引用：使用场景：用来修饰形参，使其只读，防止误操作 函数进阶函数的默认参数类型 名（参数名&#x3D;默认值）{} 若某位置有默认值，则该位置往后必须全部有默认参数（规定） 声明和实现只可以有一个有默认参数（规定） 如果函数参数值&gt;传入参数值，则从第一个参数开始向后填充，若某参数未被填充且没有默认值，则会报错 函数的占位参数调用函数时必须填补该位置 函数重载满足条件： 同一个作用域下 函数名称相同 函数参数(类型&#x2F;个数&#x2F;顺序)不同 函数返回值并不作为函数重载的条件注意事项： 引用可以作为重载的条件 重载遇到默认参数时，警惕UB（二义性）报错 面向对象基本特性：继承、多态、封装 struct和class的区别： struct的默认权限为公共 class默认权限为私有 构造函数的分类和调用调用方式： 拷贝构造函数的调用时机 使用一个对象来初始化另一个对象 以值传递的方式给函数参数赋值 自动调用拷贝构造函数创造副本 以值方式返回局部对象 此时被返回的对象会被拷贝构造 构造函数调用规则 默认存在构造函数、析构函数、拷贝构造函数 如果定义有参构造函数，只会提供默认拷贝构造 如果定义拷贝构造函数，不会提供其他构造函数 深拷贝和浅拷贝浅拷贝：简单的复制拷贝，默认的拷贝构造函数拷贝方法 容易带来的问题：若存在堆区空间的操作，容易造成重复释放与重复操作深拷贝：在堆区重新申请空间，进行数据拷贝 初始化列表qwq():a(10),b(20){}&#x2F;&#x2F;一个让a的默认值为10，b的默认值为20的无参构造函数qwq(int a,int b):a(a),b(b){}&#x2F;&#x2F;一个让a的值为a，b的值为b的有参构造函数 类对象作为类成员 静态成员静态成员变量特点： 所有对象共享统一数据 在编译阶段即分配内存 类内声明，类外初始化 仍然存在访问权限 静态成员变量访问方式： 通过对象进行访问 通过类名进行访问 静态成员函数特点： 所有对象共享同一个函数 静态成员函数只能访问静态成员变量 存在访问权限静态成员函数调用方法： 通过对象进行访问 通过类名进行访问 C++对象内存模型和this指针只有非静态成员变量才属于类的对象成员变量和成员函数是分开存储的静态成员变量和成员函数只有一份拷贝this指针：指向被调用的成员函数所属的对象奇怪的用法：可以使用空指针调用成员函数 const修饰成员函数 const修饰的函数成为常函数 常函数不可以修改成员属性 可以修改有关键字mutable的成员变量 友元关键字： friend作用：让一个函数或者类区访问另一个类的私有成员三种实现方式： 全局函数作友元 类作友元 成员函数作友元 运算符重载作用：对已有的运算符进行重新定义，以适应不同的数据类型函数名：operator*(被重载的运算符)注意： 对于内置的数据类型的运算是不可以重载的 不要滥用，尽量让运算符和实际作用相符 加号运算符重载 左移运算符重载 递增运算符重载 赋值运算符重载知识点：C++编译器会给一个类添加赋值运算符&#x3D;对属性进行值拷贝（默认为浅拷贝） 复习！浅拷贝在什么情况下会出问题！ 答：涉及到堆区内存申请&#x2F;释放的时候 函数调用运算符()重载&#x2F;&#x2F;因为长得真的很像自定义函数，又称之为仿函数&#x2F;&#x2F;仿函数没有固定写法，非常灵活 继承基本语法：class 派生类名：继承方式1 基类1,继承方式2 基类2……C++中一个类可以由多个类派生而来多继承中如果涉及到同名问题，加作用域以访问不同父类中的成员但是在实际开发中不建议使用多继承 继承方式继承后private成员不可用，成员权限会有所改变 公有继承 不改变权限 私有继承 public&amp;protected-&gt;private 保护继承 public-&gt;protected 继承中的对象模型基类所有的非静态成员变量，在派生类中仍然存在，只是被编译器隐藏了 继承中构造和析构顺序继承后在类初始化时，基类和派生类的构造函数和析构函数都会被分别调用具体调用顺序：先调用基类构造函数，再调用派生类构造函数，析构函数顺序相反 继承中同名成员的处理方式在继承后，同名成员会共存（静态成员也是）访问派生类中同名成员，可以直接访问访问基类中同名成员，需要加作用域如果基类和派生类中存在同名函数，父类中同名函数会被隐藏，如果要访问，需要加作用域 菱形继承定义：两个派生类继承同一个基类，某个类同时继承这两个派生类可能导致的问题：数据重复，资源浪费解决方案：虚继承（在第一次继承的两个派生类上发生）(关键词virtual)vbptr（Virtual Base Pointer）:虚基类指针，指向虚基类表 指针占4个内存嗷采用虚继承后，来自同一个上层基类的数据会只存在一份拷贝，对于直接继承的两个基类，存在一个vbptr，指向虚基类表中的偏移量，即为那一份拷贝在多少位之后 多态 静态多态：函数重载和运算符重载，复用函数名，依靠传入参数类型和个数区分 编译阶段确定函数地址 动态多态：派生类和虚函数实现运行时多态 运行阶段确认函数地址如何实现动态多态？函数前加virtual关键字，使其变成虚函数class animal{public: virtual void speak(){ cout&lt;&lt;”animal speak”; }}class cat: public animal{public: virtual void speak(){ cout&lt;&lt;”cat speak”; }}class dog: public animal{public: virtual void speak(){ cout&lt;&lt;”dog speak”; }}void doSpeak(Animal &amp;animal)&#x2F;&#x2F;也可以是指针{ animal.spaek(); &#x2F;&#x2F;可以传入animal,dog,cat &#x2F;&#x2F;此时若调用doSpeak函数，会根据传入的参数选择调用哪一个类中的speak函数} 内部实现vfptr(Virtual Function Pointer):虚函数指针指向虚函数表vftable(Virtual Function Table)虚函数表内容：函数-&gt;入口地址动态多态的原理：每个类都维护一个虚函数表（函数-&gt;入口地址），如果它重写了父类的函数，那么会用新函数的地址替代旧函数的地址以上文的代码为例，cat类重写了speak函数，当cat被传入doSpeak函数中时，调用animal.speak，此时animal是对该cat对象的引用，所以会从cat类的虚函数表中查找speak函数，查找到的就是输出”cat speak” 纯虚函数virtual 返回值类型 函数名 (参数) &#x3D;0;有纯虚函数的类一定是抽象类，无法被实例化，子类必须重写纯虚函数可以类比java中的abstract方法 虚析构和纯虚析构现存的问题：使用多态时，若子类有属性在堆区需要在析构函数时调用delete释放，那么父类指针在释放时(delete 父类;)无法调用到子类的析构代码，只会调用父类的析构函数解决方法：将父类的析构函数改为虚析构或者纯虚析构 虚析构和纯虚析构的共性： 可以解决堆区内存释放问题 需要有具体的函数实现区别： 有纯虚析构的类为抽象类，无法被实例化，派生类必须重写析构函数 C++ 文件操作包含库：文件分为两种： 文本文件 二进制文件操作文件的三大类： ofstream 写操作 ifstream 读操作 fstream 读写操作总体操作流程创建流对象-&gt;open(“path”,way)-&gt;写入数据-&gt;close|—-|—-||打开方式|解释||ios::in|为读文件而打开文件||ios::out|为写文件而打开文件||ios::ate|初始位置：文件尾||ios::app|追加方式写文件||ios::trunc|先删除，再创建新的||ios::bindry|以二进制方式打开文件| 可以使用|运算符，同时以多种方式打开文件 C++提高编程泛型编程（模板）建立一个通用模具，提高代码复用性 函数模板 使用方法： 注意事项： 自动类型推导，必须推导出一致的数据类型t才可以使用 类型的一致性 模板必须要确定出T的数据类型才可以使用 模板对应的函数必须指出T的数据类型 函数模板和普通函数的区别： 普通函数调用可以发生隐式类型转换 函数模板如果使用自动类型推导，不会发生隐式类型转换 函数模板如果使用显式指定类型，可以发生隐式类型转换 函数模板调用规则 如果函数模板和普通函数都可以实现，优先调用普通函数 可以通过空模板参数列表来强制调用函数模板 函数模板也可以发生重载 如果函数模板可以更好的匹配，优先调用函数模板总结：尽量不要让模板和普通函数功能重合，容易产生二义性 模板的局限性对于特定数据类型（class等），需要具体化方式做特殊实现常见相关解决方法：运算符重载（治标不治本）、具体化实现 类模板 类模板和函数模板的区别 类模板不可以采用自动类型推导的使用方式 类模板在模板参数列表可以有默认参数 成员函数创建时期 成员函数在调用时才被创建可能出现的情况：模板类中定义的函数，在模板被实现后无法被调用换种说法，若出现该类问题，不会在编译时被编译器查出 类模板对象作函数参数传入方式： 指定传入的类型 直接显示对象的数据类型 参数模板化 将对象中的参数变为模板进行传递 整个类模板化 将这个对象类型模板化进行传递 类模板与继承 当子类继承的父类是一个类模板时，子类在声明时需要指定T的类型 如果不指定，编译器无法给子类分配内存 如果想灵活指定T的类型，子类也需要为类模板 类模板成员函数的类外实现 类模板分文件编写问题：成员函数在调用阶段生成，导致分文件编写时无法被链接解决方案： 直接包含cpp源文件（会通过.cpp的头文件自动包含.h文件） 将声明和实现写到同一个文件中，并更改后缀名为hpp（约定） 类模板与友元类内实现：直接在类内声明友元即可类外实现：提前让编译器知道全局函数存在 "},{"title":"About 2022","date":"2022-11-27T13:54:30.000Z","url":"/2022/11/27/About-2022/","categories":[[" ",""]],"content":"永恒是颗虚伪的糖，任回忆终堆积成墙。 是谁说了谎，还要一直伪装 Hello-龚言脩也是上文中歌词的出处 好像上一秒还在2021跨年夜，转瞬间2022都快结束了今天是11月27日，济南站结束，大学的ICPC奋斗史也划上了一个句号，思绪万千，但不知道该从哪里写起，索性就提前把坑开好，之后慢慢找补吧 一月份 去上海玩了一圈，这是人生第一次自己去想去的地方旅游，和两个🐖一起 多校，一周四场，补题补得像是人间炼狱 二月份-五月份 赶着开学前把阑尾切掉了，本来想借着手术得由头晚几天返校，谁知道一晚就是三个月，五月初才返校 好像这几个月除了csgo技术见涨以外没有什么收获 四级裸考一次过(知道自己很弱，大佬们求轻喷):( 六月份 工程训练好像挺有意思的 从零开始的期末考试 系统分析与设计、计算机网络、操作系统 在家做的课设，还有答辩，录屏是真的无聊哇 七月份-八月份 和傻狗（@Yongtai）一起鬼混了两个月 九月份-十月份 转眼大三了，普通的上课生活 十一月 ICPC济南站铁牌，做了五道题，过了两道题，哎 TAT 新生赛顺利举办，撒花，协会纳新完成，协会的事情以后就交给大二同学们管了 期末还是一如既往的早呀，十一月十几号就把项目管理和软件测试考完了 我是不可能挂科的！ 十一月打完了九月开始的5E定级 2100!水平还在! 十二月 502被收了，完结撒花，协会解散吧，都别活 课设，是在做课设吗？是在渡劫 得新冠啦，虽然没发烧，但是身上没劲，头疼流鼻涕，呜呜呜 见证历史，但买不到抗原 "},{"title":"Hello","date":"2022-11-26T08:20:22.000Z","url":"/2022/11/26/Hello/","categories":[[" ",""]],"content":"这个网站是怎么来的呢? 这个域名(lxy12138.com)是在2014年被第一次注册的。在一开始的三年，站点部署在47姐姐的私人服务器上（感谢47姐姐的慷概解囊）大概从2018年开始，由于各种原因，站点不再更新，也一度陷入停站状态，仅保留了域名邮箱的使用:-( (高中真的又忙又穷谁有时间天天管一个网站嘤嘤嘤)在2022年末，由于懒狗赵石突然决定做些什么事情，于是，他重建了这个网站也就是现在你看到的，赵石的小窝 V2.0 嗨，别来无恙啊;-) Reach me at: &#x73;&#x74;&#x7a;&#x32;&#x30;&#49;&#x35;&#x40;&#x6f;&#117;&#116;&#108;&#111;&#x6f;&#107;&#46;&#x63;&#x6f;&#109;"}]