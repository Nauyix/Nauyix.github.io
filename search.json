[{"title":"STL容器简介","date":"2023-03-17T09:03:34.000Z","url":"/2023/03/17/STL/","categories":[[" ",""]],"content":"STL一共有__7__种序列容器，__4__种关联容器，__4__种无序关联容器 首先明确定义：什么是容器？ 容器是存储其他对象的对象 容器贯彻了C++泛型编程的思想，结合OOP理念 底层实现：类与模板 忘记了可以来开天辟地（bushi）C++笔记 注意，在不加其他限制措施的情况下，任何STL容器都是线程不安全的 序列容器序列的基本方法： 方法 含义 备注 insert() 插入一个对象 erase() 删除一个对象 需要传入迭代器 clear() 清空序列内容 元素按照线性顺序排列 vector 动态数组 支持随机访问且速度较快 可以根据数组长度动态申请内存大小 在尾部添加和删除元素的时候是固定时间复杂度 在头部添加和删除元素的时候是线性时间复杂度 可反转 deque 双端队列 支持随机访问 在首位添加或删除元素的时候是固定时间复杂度（效率低于vector） 可反转 list 双向链表 不支持随机访问 任意插入或删除都是线性时间复杂度 存在sort成员函数 forward 单向链表 不支持随机访问 不可反转 在C++11后提供 queue 队列 性质如其名 为deque的封装 priority_queue pq(greater) 优先队列 底层使用堆实现 队列内数据有序 性质如其名 stack 栈 性质如其名 为deque的封装 关联容器 保存k-v数据 元素保存有序 查询性能和插入性能较稳定，一般为log级 一般底层使用树存储 set 集合容器 没有kv，k就是v 可反转 可排序，默认升序 键唯一，不可重复 提供交并差运算(略复杂) multiset 多重集合 在set的基础上允许重复 map 映射 k-v结构，键不可重复 查询和插入都是稳定的log(n) 可反转，有排序 multimap 多重映射 在map的基础上允许重复 无序关联容器（哈希容器） 保存k-v数据 元素保存无序 查询与插入性能优异，一般为O(1) 遍历性能较差 一般底层使用哈希存储 "},{"title":"C++笔记","date":"2023-03-12T09:15:50.000Z","url":"/2023/03/12/C/","categories":[[" ",""]],"content":"有人查漏补缺，有人精卫填海，有人开天辟地(bushi 内存的分区模型代码区：存放函数体的二进制代码全局区：存放全局变量、静态变量、常量栈区：由编译器自动分配&#x2F;释放，存放函数参数和局部变量等堆区：由程序员分配和释放，若未释放则在程序结束时由操作系统回收 代码区的特点：共享（多次执行只需要一份代码即可），只读（防止意外修改）全局区的特点：数据在程序结束后由操作系统释放栈区的特点：保存在栈区的数据在函数执行完即自动释放堆区的特点：用new开辟，由程序员指定分配 引用（给变量起别名）,指向同一片内存空间意义：要求： 一定要初始化 一旦初始化了，就不可以更改了 参数传递 值传递 地址传递 引用传递 引用作函数返回值含义：如果一个函数的返回值是引用，那么这个函数可以作为左值 不要返回局部变量的引用 引用的本质：一个指针常量，指针不可以修改，但是指针指向的值可以修改由编译器完成（引用→指针常量）的过程常量引用：使用场景：用来修饰形参，使其只读，防止误操作 函数进阶函数的默认参数类型 名（参数名&#x3D;默认值）{} 若某位置有默认值，则该位置往后必须全部有默认参数（规定） 声明和实现只可以有一个有默认参数（规定） 如果函数参数值&gt;传入参数值，则从第一个参数开始向后填充，若某参数未被填充且没有默认值，则会报错 函数的占位参数调用函数时必须填补该位置 函数重载满足条件： 同一个作用域下 函数名称相同 函数参数(类型&#x2F;个数&#x2F;顺序)不同 函数返回值并不作为函数重载的条件注意事项： 引用可以作为重载的条件 重载遇到默认参数时，警惕UB（二义性）报错 面向对象基本特性：继承、多态、封装 struct和class的区别： struct的默认权限为公共 class默认权限为私有 构造函数的分类和调用调用方式： 拷贝构造函数的调用时机 使用一个对象来初始化另一个对象 以值传递的方式给函数参数赋值 自动调用拷贝构造函数创造副本 以值方式返回局部对象 此时被返回的对象会被拷贝构造 构造函数调用规则 默认存在构造函数、析构函数、拷贝构造函数 如果定义有参构造函数，只会提供默认拷贝构造 如果定义拷贝构造函数，不会提供其他构造函数 深拷贝和浅拷贝浅拷贝：简单的复制拷贝，默认的拷贝构造函数拷贝方法 容易带来的问题：若存在堆区空间的操作，容易造成重复释放与重复操作深拷贝：在堆区重新申请空间，进行数据拷贝 初始化列表qwq():a(10),b(20){}&#x2F;&#x2F;一个让a的默认值为10，b的默认值为20的无参构造函数qwq(int a,int b):a(a),b(b){}&#x2F;&#x2F;一个让a的值为a，b的值为b的有参构造函数 类对象作为类成员 静态成员静态成员变量特点： 所有对象共享统一数据 在编译阶段即分配内存 类内声明，类外初始化 仍然存在访问权限 静态成员变量访问方式： 通过对象进行访问 通过类名进行访问 静态成员函数特点： 所有对象共享同一个函数 静态成员函数只能访问静态成员变量 存在访问权限静态成员函数调用方法： 通过对象进行访问 通过类名进行访问 C++对象内存模型和this指针只有非静态成员变量才属于类的对象成员变量和成员函数是分开存储的静态成员变量和成员函数只有一份拷贝this指针：指向被调用的成员函数所属的对象奇怪的用法：可以使用空指针调用成员函数 const修饰成员函数 const修饰的函数成为常函数 常函数不可以修改成员属性 可以修改有关键字mutable的成员变量 友元关键字： friend作用：让一个函数或者类区访问另一个类的私有成员三种实现方式： 全局函数作友元 类作友元 成员函数作友元 运算符重载作用：对已有的运算符进行重新定义，以适应不同的数据类型函数名：operator*(被重载的运算符)注意： 对于内置的数据类型的运算是不可以重载的 不要滥用，尽量让运算符和实际作用相符 加号运算符重载 左移运算符重载 递增运算符重载 赋值运算符重载知识点：C++编译器会给一个类添加赋值运算符&#x3D;对属性进行值拷贝（默认为浅拷贝） 复习！浅拷贝在什么情况下会出问题！ 答：涉及到堆区内存申请&#x2F;释放的时候 函数调用运算符()重载&#x2F;&#x2F;因为长得真的很像自定义函数，又称之为仿函数&#x2F;&#x2F;仿函数没有固定写法，非常灵活 继承基本语法：class 派生类名：继承方式1 基类1,继承方式2 基类2……C++中一个类可以由多个类派生而来多继承中如果涉及到同名问题，加作用域以访问不同父类中的成员但是在实际开发中不建议使用多继承 继承方式继承后private成员不可用，成员权限会有所改变 公有继承 不改变权限 私有继承 public&amp;protected-&gt;private 保护继承 public-&gt;protected 继承中的对象模型基类所有的非静态成员变量，在派生类中仍然存在，只是被编译器隐藏了 继承中构造和析构顺序继承后在类初始化时，基类和派生类的构造函数和析构函数都会被分别调用具体调用顺序：先调用基类构造函数，再调用派生类构造函数，析构函数顺序相反 继承中同名成员的处理方式在继承后，同名成员会共存（静态成员也是）访问派生类中同名成员，可以直接访问访问基类中同名成员，需要加作用域如果基类和派生类中存在同名函数，父类中同名函数会被隐藏，如果要访问，需要加作用域 菱形继承定义：两个派生类继承同一个基类，某个类同时继承这两个派生类可能导致的问题：数据重复，资源浪费解决方案：虚继承（在第一次继承的两个派生类上发生）(关键词virtual)vbptr（Virtual Base Pointer）:虚基类指针，指向虚基类表 指针占4个内存嗷采用虚继承后，来自同一个上层基类的数据会只存在一份拷贝，对于直接继承的两个基类，存在一个vbptr，指向虚基类表中的偏移量，即为那一份拷贝在多少位之后 多态 静态多态：函数重载和运算符重载，复用函数名，依靠传入参数类型和个数区分 编译阶段确定函数地址 动态多态：派生类和虚函数实现运行时多态 运行阶段确认函数地址如何实现动态多态？函数前加virtual关键字，使其变成虚函数class animal{public: virtual void speak(){ cout&lt;&lt;”animal speak”; }}class cat: public animal{public: virtual void speak(){ cout&lt;&lt;”cat speak”; }}class dog: public animal{public: virtual void speak(){ cout&lt;&lt;”dog speak”; }}void doSpeak(Animal &amp;animal)&#x2F;&#x2F;也可以是指针{ animal.spaek(); &#x2F;&#x2F;可以传入animal,dog,cat &#x2F;&#x2F;此时若调用doSpeak函数，会根据传入的参数选择调用哪一个类中的speak函数} 内部实现vfptr(Virtual Function Pointer):虚函数指针指向虚函数表vftable(Virtual Function Table)虚函数表内容：函数-&gt;入口地址动态多态的原理：每个类都维护一个虚函数表（函数-&gt;入口地址），如果它重写了父类的函数，那么会用新函数的地址替代旧函数的地址以上文的代码为例，cat类重写了speak函数，当cat被传入doSpeak函数中时，调用animal.speak，此时animal是对该cat对象的引用，所以会从cat类的虚函数表中查找speak函数，查找到的就是输出”cat speak” 纯虚函数virtual 返回值类型 函数名 (参数) &#x3D;0;有纯虚函数的类一定是抽象类，无法被实例化，子类必须重写纯虚函数可以类比java中的abstract方法 虚析构和纯虚析构现存的问题：使用多态时，若子类有属性在堆区需要在析构函数时调用delete释放，那么父类指针在释放时(delete 父类;)无法调用到子类的析构代码，只会调用父类的析构函数解决方法：将父类的析构函数改为虚析构或者纯虚析构 虚析构和纯虚析构的共性： 可以解决堆区内存释放问题 需要有具体的函数实现区别： 有纯虚析构的类为抽象类，无法被实例化，派生类必须重写析构函数 C++ 文件操作包含库：文件分为两种： 文本文件 二进制文件操作文件的三大类： ofstream 写操作 ifstream 读操作 fstream 读写操作总体操作流程创建流对象-&gt;open(“path”,way)-&gt;写入数据-&gt;close|—-|—-||打开方式|解释||ios::in|为读文件而打开文件||ios::out|为写文件而打开文件||ios::ate|初始位置：文件尾||ios::app|追加方式写文件||ios::trunc|先删除，再创建新的||ios::bindry|以二进制方式打开文件| 可以使用|运算符，同时以多种方式打开文件 C++提高编程泛型编程（模板）建立一个通用模具，提高代码复用性 函数模板 使用方法： 注意事项： 自动类型推导，必须推导出一致的数据类型t才可以使用 类型的一致性 模板必须要确定出T的数据类型才可以使用 模板对应的函数必须指出T的数据类型 函数模板和普通函数的区别： 普通函数调用可以发生隐式类型转换 函数模板如果使用自动类型推导，不会发生隐式类型转换 函数模板如果使用显式指定类型，可以发生隐式类型转换 函数模板调用规则 如果函数模板和普通函数都可以实现，优先调用普通函数 可以通过空模板参数列表来强制调用函数模板 函数模板也可以发生重载 如果函数模板可以更好的匹配，优先调用函数模板总结：尽量不要让模板和普通函数功能重合，容易产生二义性 模板的局限性对于特定数据类型（class等），需要具体化方式做特殊实现常见相关解决方法：运算符重载（治标不治本）、具体化实现 类模板 类模板和函数模板的区别 类模板不可以采用自动类型推导的使用方式 类模板在模板参数列表可以有默认参数 成员函数创建时期 成员函数在调用时才被创建可能出现的情况：模板类中定义的函数，在模板被实现后无法被调用换种说法，若出现该类问题，不会在编译时被编译器查出 类模板对象作函数参数传入方式： 指定传入的类型 直接显示对象的数据类型 参数模板化 将对象中的参数变为模板进行传递 整个类模板化 将这个对象类型模板化进行传递 类模板与继承 当子类继承的父类是一个类模板时，子类在声明时需要指定T的类型 如果不指定，编译器无法给子类分配内存 如果想灵活指定T的类型，子类也需要为类模板 类模板成员函数的类外实现 类模板分文件编写问题：成员函数在调用阶段生成，导致分文件编写时无法被链接解决方案： 直接包含cpp源文件（会通过.cpp的头文件自动包含.h文件） 将声明和实现写到同一个文件中，并更改后缀名为hpp（约定） 类模板与友元类内实现：直接在类内声明友元即可类外实现：提前让编译器知道全局函数存在 "},{"title":"pgsql","date":"2023-02-28T12:17:18.000Z","url":"/2023/02/28/pgsql/","categories":[[" ",""]],"content":"大二没好好学呜呜呜 SQL 备忘录SQL 备忘录 基本语句格式 select from where group by 按照一定规则分组，可以有多个参数 多参数时，若两参数的参照关系完全相同，会归为一类 多参数时，会按照设置的参数项目对结果进行分类 必须与聚合函数（count()\\sum()等）搭配使用，否则会报错 order by 按照一定规则排序 order by colomn [asc|desc] asc:Ascend 升序 desc:Descend 降序 关键字 distinct 保证结果（根据某一列&#x2F;多列）严格不相同 join 连接 见6 as 为某项数据设置别名，一般在存在复杂子查询时使用 exists 后接内层子查询，返回结果为Yes或No，若外层查询到的数据在内层中满足条件的出现过，则返回Yes limit 用在from后：可以设置搜索的偏移量，提升搜索效率，select * from table limit 起始行,向后偏移量（-1则搜索到表结尾） 用在where后：限制结果数量，搜索到指定数量的记录后即停止搜索，避免搜索全表 select * from table where colomn&#x3D;? limit 1 union 用在两个select整体之间，用来连接搜索结果，要求被连接的两个表拥有严格相似的结构 in&#x2F;not in 用于限制条件，可以限制搜索目标in(ans1,ans2,ans3……) like &amp;&amp; ilike 见7 having 过滤搜索结果，见8 内置函数 generate_series(start, stop, step),可以用于数字&#x2F;时间的序列生成，step可以为除了0以外的任何实数 row_number() over (order by colomn [asc|desc]) 对于某列的数据按照[升序|降序]生成序列，遇到相同数据不会生成重复序号 rank() over (order by colomn [asc|desc]) 对于某列的数据按照[升序|降序]生成序列，遇到相同数据会生成重复序号，相同的数据只占用一个名次 dense_rank() over (order by colomn [asc|desc]) 对于某列的数据按照[升序|降序]生成序列，遇到相同数据会生成重复序号，相同的数据占用多个名次 NTILE(number) over (order by colomn [asc|desc]) 对于某列的数据按照[升序|降序]生成序列，每个数字项出现number次 聚合函数 count sum 范式 1NF 数据是不可再分的 解决方法：拆数据项 2NF 在1NF的基础上，消除了非主属性对于码的部分函数依赖，即保证通过主键可以唯一确定该项每一列的值 解决方法：拆表 3NF 在2NF的基础上，一个表中不可以存在任何非主属性可以被另一项非主属性唯一确定 解决方法：进一步拆表 表达式 case表达式 简单case表达式 连接 inner join left (outer) join right (outer) join full outer join粗浅的理解：先发生表结构拼接 join 中文 粗浅的理解 备注 inner join 内连接 A交B left (outer) join 左(外)连接 A并(A交B) B表中没有的内容留空 right (outer) join 右(外)连接 (A交B)并A A表中没有的内容留空 full outer join 全外连接 A并(A交B)并B AB中互相没有的留空，然后补齐在总表下方 A join B on 匹配条件仅保存符合匹配条件的数据库记录 通配符与模糊搜索 like &amp;&amp; ilike like在搜索时区分大小写 但ilike不区分 两个通配符 _ 占位通配符，该通配符出现的次数严格匹配目标的格式，如_0，则目标字串的第二位一定为0 % 不占位通配符，该通配符出现的地方不限制字符数字，可以为0-n个字符填充，如%0，此时目标串含有0则会被选中语句示例：select * from table where colomn like ‘%_00’ like可以用于复制一张表的结构 （不包含数据） create table table2(like table1) having的用法 区分having和where： where是直接在搜索的时候进行筛选，having是过滤搜索结果 执行顺序：where-→聚合函数-→having having后面可以使用聚合函数，但where不可以 "},{"title":"maven笔记","date":"2023-02-21T06:45:25.000Z","url":"/2023/02/21/maven%E7%AC%94%E8%AE%B0/","categories":[[" ",""]],"content":"喔，填坑呢在这 组成 坐标 groupId 隶属组织名称 artifactId 当前项目名称 version 当前版本号 packaging 打包方式（默认为jar） 作用：唯一定位该资源，查找、下载并使用资源 配置 环境变量MAVEN_HOME 可以配置settings.xml（全局生效），也可以配置pom.xml（对当前项目生效） 本地仓库配置… 配置镜像仓库（加速下载，常用阿里云仓库）… 依赖 项目可以依赖项目 项目可以依赖现成的包 依赖中存在的问题： 路径优先:当依赖中出现相同的资源时，层级越深，优先级越低，层级越浅，优先级越高 声明优先:当资源在相同层级被依赖时，配置顺序靠前的覆盖配置顺序靠后的 特殊优先:当同级配置了相同资源的不同版本，后配置的覆盖先配置的 可选依赖 场景：不希望别人知道我用过这个依赖 true 效果：当前项目使用该依赖，但依赖该项目的项目不自动引用该依赖 排除依赖 场景：不希望使用某依赖 在一个dependency里写： 效果：若当前项目排除了依赖项目的A依赖，则该A依赖不会被当前应用所依赖 依赖范围：注意：依赖范围具有传递性 scope 主代码 测试代码 打包 compile(默认) 1 1 1 test 0 1 0 provided 1 1 0 runtime 0 0 1 生命周期与插件clean 清理 pre-clean clean post-cleandefault 核心工作（编译、测试、打包、部署） site 产生报告 pre- site post-site site-deploy 插件：与生命周期相绑定或者可以说maven的每一个生命周期都是利用插件来实现的 引入引入方式同依赖，只不过把dependency改成plubins&#x2F;plugin&lt;groupId&gt;…&lt;&#x2F;groupId&gt;&lt;artifactId&gt;….&lt;&#x2F;artifactId&gt;&lt;version&gt;…&lt;&#x2F;version&gt; 目标设置&lt;executions&gt;…&lt;&#x2F;executions&gt;下层：指令&lt;&#x2F;goal&gt;运行阶段&lt;&#x2F;phase&gt;即为在哪个生命周期中执行该插件 分模块开发与设计总目标：将程序拆装成不同模块，利用接口通信 （不是java的接口）controller 控制层service 业务层dao 持久层pojo 展示层 聚合依赖用一个模块来管理其他模块 设置聚合模块打包方式为pom &lt;modules&gt;被聚合的工程列表&lt;&#x2F;modules&gt; 继承 模块依赖关系维护 子模块可以声明需要依赖，但是不限定版本，若出现版本冲突则会难以解决 解决方案： 在聚合模块中声明所有的依赖 在子模块中声明&lt;parent&gt;工件ID&#x2F;版本&#x2F;GroupId….&lt;&#x2F;parent&gt; 子工程在设计dependency时不需要写version继承的作用：子工程中沿用父工程的依赖配置 属性定义自定义属性 版本管理 关于版本号命名的小常识 snapshot 开发过程中，为方便合作或解决依赖等，输出的临时性版本，会随着开发的进展不断更新，更新周期较短 release 经过测试后，团队对外发布的，运行较为稳定的版本，更新周期较长 关于版本号的一些约定：&lt;主版本&gt;&lt;次版本&gt;&lt;增量版本&gt;&lt;里程碑版本&gt; 如：5.1.13-Release 多环境开发配置-不需逐个更改文件即可兼容（生产环境&#x2F;开发环境&#x2F;测试环境……） 执行特定环境方法：mvn -P [环境名称] 跳过测试 常用场景： 模块功能未开发（完毕） 单个功能更新导致其他功能失效 快速打包 方式 在maven配置窗口跳过 mvn -D skipTests 在pom中配置测试插件(maven-surefire-plugin)，设置&lt;skipTests&gt;true&lt;&#x2F;skipTests&gt;(不建议使用) 只使用部分用例测试 在测试插件(maven-surefire-plugin)的configuration中，设置include-对应的测试用例(.java) "},{"title":"Spring笔记","date":"2023-02-05T13:46:09.000Z","url":"/2023/02/05/Spring%E7%AC%94%E8%AE%B0/","categories":[[" ",""]],"content":"Spring框架笔记 开闭原则（Open Cloce Protocal, OCP）：软件应对扩展开放，对修改关闭 依赖倒转原则（Dependency Inversion Principle, DIP）： 高层模块不应该依赖低层模块，二者都应该依赖其抽象 中心思想：面向接口编程，面向抽象编程 目的：降低程序耦合，提高扩展性能 控制反转 编程思想（Inversion of Control, IoC） 不在程序中采用硬编码的方式来新建对象 不在程序中采取硬编码的方式来维护对象关系 由于出现较晚，没有被纳入GoF23种设计模式范围内 实现方式较多，其中比较重要的有：依赖注入（Dependency Injection, DI） IoC是思想，DI是实现 注入方法：Set方法注入&#x2F;构造方法注入 set注入 构造方法注入 Spring框架 实现控制反转IoC，协助新建对象&#x2F;维护对象关系 实现IoC思想的容器 八大模块： Core: 基于IoC的核心，实现对Bean的管理，主要组件是BeanFactorty AOP: 次核心，面向切面编程 Web MVC: Spring自己提供的一套MVC框架（暨SpringMVC） WebFlux: 响应式Web框架 Web: 支持集成常见的Web框架（如struts，webwork） DAO: 提供了单独的支持JDBC操作的API ORM: 支持集成常见的ORM框架（如MyBatis,Hibernate） Context: 提供扩展服务 特点 轻量 非侵入式：Spring应用中对象不依赖Spring的特定类 轻量：体积小 控制反转：底层使用工厂模式（XML解析+工厂模式+反射机制） 面向切面 容器 框架 pom.xml packaging 打包方式 repositories 仓库地址 dependencies 依赖 Spring的配置文件 放在resources目录下的xml文件 配置标签，让spring创造对象 bean的两个重要属性： id bean的唯一标识符 类的全限定类名（带包名） Spring容器的使用 获取Spring容器对象：ApplicationContext ac&#x3D;new ClassPathXmlApplicationContext(“配置文件路径”) 注意：运行上一行句内代码即视为启动Spring容器，解析xml文件，并实例化其所有的Bean对象 根据BeanID获取对象：ac.getBean(“Bean的ID”,bean类型.class); 参数2若留空，返回类型默认为Object spring框架通过反射机制来创建对象→一定要保证无参构造方法存在 Class cz&#x3D;Class.forName(“完整类名”) Object obj&#x3D;cz.newInstance() 底层使用Map&lt;String,Object存储&gt; 同一个xml文件内不可以有同id的bean，若同时加载多个xml后，存在同id的bean，后加载的bean的会覆盖先加载的bean，被覆盖的bean不会被实例化（猜测：也许是先加载完所有的bean然后再统一实例化？） getBean的时候不可以虚空索敌，会报错 启动Log4j2日志框架 引入依赖 创建xml配置文件 在项目内记录日志信息 创建日志记录器对象 根据不同级别输出日志 set注入详解 注入外部Bean：外部定义好bean，property中使用ref引用 注入内部Bean：在内部property中嵌套定义bean，不用写ref(少用) 注入简单类型（如int，char，enum等）：property中不指定ref，property指定value Date虽然可以使用value赋值，但对于格式有着严格的要求，如Mon Feb 6 14:50:17 CST 2023，所以尽量还是用ref 级联属性赋值：\\&lt;property name=id.属性 value=&quot;&quot;/\\&gt; 注意：如果想要使用级联属性赋值，需要编写对应id-bean的get方法 注入数组：property内嵌array，使用value&#x2F;ref填充 注入List&#x2F;Set&#x2F;Map&#x2F;属性类 注入null和空字符串 命名空间注入 p命名空间注入 目的：简化配置 基于set注入 配置文件头：xmlns:p&#x3D;” c命名空间注入 目的：简化配置 基于构造方法注入 配置文件头：xmlns:p&#x3D;” util命名空间实现配置复用 配置文件头：xmlns:p&#x3D;” 更改schemaLocation:www.springframework.org/schema/util ; 基于XML的自动装配 根据名字进行自动装配，底层基于set方法 被自动注入的bean的id需要和set方法中的name一致（去掉set首字母小写） 根据类型进行自动装配，底层基于set方法 一个类型的对象只可以有一个 引入外部properties文件 配置文件头，引入context命名空间：xmlns:p&#x3D;” 更改schemaLocation:www.springframework.org/schema/context ; 使用context:property-placeholder的location属性指定路径，从根目录开始寻址 resources相当于根目录 使用${key}取值，保留双引号 警惕系统变量乱入. bean的作用域 scope项： Spring默认是单例的，即singleton，启动容器时即创建对象 将bean的scope属性设置为prototype则为多例，此时每一次getBean则实例化一次 若引用SpringMVC框架，可有request（一次请求一个bean）和session（一次会话一个值） 还有其他少用scope项 如global session(portlet应用专用)\\application(一个应用)\\websocket(一个生命周期)\\自定义 bean的实例化 构造方法实例化-自动调用无参构造方法 简单工厂模式实例化 factory-bean实例化 FactoryBean接口实例化 Bean的生命周期 实例化 Bean属性赋值2.5 检查Bean是否实现了Aware相关接口，并设置相关依赖 执行“bean后处理器”的before方法3.5 检查Bean是否实现了InitializingBean接口，调用方法 初始化bean（xml中配置init-method&#x3D;””） 执行“bean后处理器”的after方法 使用bean6.5 检查Bean是否实现了DisposableBean接口并调用接口方法 销毁bean（xml中配置destroy-method&#x3D;””） bean后处理器: implements BeanPostProcessor并重写其before和after方法，写完在xml中创建该bean即可 一旦配置则对当前xml所有的bean都生效 作用：检查Bean是否实现了某些特定的接口 Spring容器仅对singleton的bean进行完整的生命周期管理，其他scope只负责初始化完毕 Bean的循环依赖 spring仅可以自动处理set注入&#x2F;singleton情况下的循环依赖问题 构造注入&#x2F;(singleton&#x2F;prototype&#x2F;Others)情况下__无法解决__原理：调用无参构造方法实例化对象（此时即曝光该Bean对象），然后使用set注入 Bean的三级缓存private final Map&lt;String,Object&gt; singletonObjects 一级缓存private final Map&lt;String,Object&gt; earlysingletonObjects 二级缓存private final Map&lt;String,ObjectFactory&lt;?&gt;&gt; singletonFactories 三级缓存(该map集合即被称为缓存)key为bean的idvalue:一级缓存：经过注入后完整的bean对象二级缓存：已经被实例化，但是还没有赋值属性的bean对象三级缓存：单例工厂对象 Spring IoC 注解式开发目的：简化XML配置使用方式：在配置文件中添加aop依赖，配置context命名空间，配置扫描，在类上只用注解 选择性实例化bean "},{"title":"About-2023","date":"2023-02-01T14:18:58.000Z","url":"/2023/02/01/About-2023/","categories":[[" ",""]],"content":"在这个世界，有一点希望 有一点失望，我时常这么想 这个世界-孙燕姿2023才刚刚开始，歌曲可能会随每月心情而更改;-) 今年更是全新开坑的一年！我决定年初就开始写总结！ 一月份 双板滑雪入门之在中级道被鱼类创飞！ 从0开始的python生活 二月份 为什么小0（@Yongtai）这么卷啊 Spring！ 从0开始的实习生活 得到又失去，相遇却别离，或许重逢，或许再而不见 开学🌶 三月份 楞学C++ 周围人都好卷啊 找不到实习了嘤嘤嘤 "},{"title":"About 2022","date":"2022-11-27T13:54:30.000Z","url":"/2022/11/27/About-2022/","categories":[[" ",""]],"content":"永恒是颗虚伪的糖，任回忆终堆积成墙。 是谁说了谎，还要一直伪装 Hello-龚言脩也是上文中歌词的出处 好像上一秒还在2021跨年夜，转瞬间2022都快结束了今天是11月27日，济南站结束，大学的ICPC奋斗史也划上了一个句号，思绪万千，但不知道该从哪里写起，索性就提前把坑开好，之后慢慢找补吧 一月份 去上海玩了一圈，这是人生第一次自己去想去的地方旅游，和两个🐖一起 多校，一周四场，补题补得像是人间炼狱 二月份-五月份 赶着开学前把阑尾切掉了，本来想借着手术得由头晚几天返校，谁知道一晚就是三个月，五月初才返校 好像这几个月除了csgo技术见涨以外没有什么收获 四级裸考一次过(知道自己很弱，大佬们求轻喷):( 六月份 工程训练好像挺有意思的 从零开始的期末考试 系统分析与设计、计算机网络、操作系统 在家做的课设，还有答辩，录屏是真的无聊哇 七月份-八月份 和小0（@Yongtai）一起鬼混了两个月 九月份-十月份 转眼大三了，普通的上课生活 十一月 ICPC济南站铁牌，做了五道题，过了两道题，哎 TAT 新生赛顺利举办，撒花，协会纳新完成，协会的事情以后就交给大二同学们管了 期末还是一如既往的早呀，十一月十几号就把项目管理和软件测试考完了 我是不可能挂科的！ 十一月打完了九月开始的5E定级 2100!水平还在! 十二月 502被收了，完结撒花，协会解散吧，都别活 课设，是在做课设吗？是在渡劫 得新冠啦，虽然没发烧，但是身上没劲，头疼流鼻涕，呜呜呜 见证历史，但买不到抗原 想给小李邦邦两拳 "},{"title":"Hello","date":"2022-11-26T08:20:22.000Z","url":"/2022/11/26/Hello/","categories":[[" ",""]],"content":"这个网站是怎么来的呢? 这个域名(lxy12138.com)是在2014年被第一次注册的。在一开始的三年，站点部署在47姐姐的私人服务器上（感谢47姐姐的慷概解囊）大概从2018年开始，由于各种原因，站点不再更新，也一度陷入停站状态，仅保留了域名邮箱的使用:-( (高中真的又忙又穷谁有时间天天管一个网站嘤嘤嘤)在2022年末，由于懒狗赵石突然决定做些什么事情，于是，他重建了这个网站也就是现在你看到的，赵石的小窝 V2.0 嗨，别来无恙啊;-) Contact me at: &#115;&#x74;&#x7a;&#x32;&#48;&#x31;&#53;&#64;&#x6f;&#x75;&#x74;&#108;&#111;&#x6f;&#x6b;&#46;&#x63;&#x6f;&#x6d;"},{"title":"Temporarily Void","date":"2022-11-25T14:43:21.270Z","url":"/2022/11/25/hello-world/","categories":[[" ",""]],"content":"New pages and articles are still on the way But Don’t worry:)It wont be too long"}]