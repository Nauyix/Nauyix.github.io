[{"title":"C++中的四种智能指针","date":"2023-04-03T12:37:45.000Z","url":"/2023/04/03/smart-pointer/","categories":[[" ",""]],"content":"一般来说，C++中一共有4种智能指针，包括引入于C++98的auto_ptr，以及引入与C++11的unique_ptr&#x2F;shared_ptr&#x2F;weak_ptr auto_ptr：源自于C++98的老大哥 信息 说明 引入于 C++98 定义于 &lt;memory&gt; 优点 当指针对象被销毁时，它所管理的对象也会自动被delete掉 缺点 让我们在下面慢慢说 创建方法 auto_ptr ap(new string(“this is an auto_ptr”)); 支持 拷贝构造，有参构造，无参构造 开始慢慢说吧 unique_ptr：auto_ptr的优秀继承者 信息 说明 引入于 C++11 定义于 &lt;memory&gt; 优点 相对于auto_ptr来说，更加安全 创建方法 unique_ptr ap(new string(“this is an unique_ptr”)); 支持 有参构造，无参构造,拷贝构造 在auto_ptr中，虽然也有所有权的定义，但只会拷贝构造时会发生所有权的转移，同一个对象仍然可以由多个不同的auto_ptr共享，因此也就造成了同一片内存空间多次释放(UB)，调用空指针等问题 但对在unique_ptr中，加强了所有权，一个对象只可以由一个unique_ptr进行独享，所有权可以被释放，可以被转移，但绝不能被共享，因此弥补了auto_ptr的一些缺陷 shared_ptr：允许多个指针指向同一个对象 信息 说明 引入于 C++11 定义于 C++11后：&lt;memory&gt; C++11前：Boost库 优点 相对于unique_ptr来说，允许多指针指向同一对象，且安全 创建方法 shared_ptr sp(new string(“this is an unique_ptr”)); 支持 有参构造，无参构造，拷贝构造 在shared_ptr中，引入了”计数器”这一概念，当多个指针指向同一个对象时，这些指针共享同一个计数器，记录着改对象被引用的次数，当指针被销毁时，计数器会同步减少，当计数器减少到0时，该对象会被自动销毁 weak_ptr：和shared_ptr通力合作的亲密友指针 信息 说明 引入于 C++11 定义于 C++11后：&lt;memory&gt; C++11前：Boost库 优点 相对于unique_ptr来说，允许多指针指向同一对象，且安全 创建方法 shared_ptr sp(new string(“this is an unique_ptr”)); 支持 无参构造，有参构造，拷贝构造 特性 可以弱引用shared_ptr且不会增加计数器计数 该指针被设计成和shared_ptr共同使用，用于观测shared_ptr目前的状态 那么这个指针的意义是什么？难道只是一个观星者吗？答案：解除循环依赖问题假设我们现在有两个对象A和B 在我们实例化A类和B类，并调用两个set方法注入A和B的成员指针后，A和B构成了循环依赖，这两个类会因为该依赖关系而都无法被自动销毁（永远都会因为对方的成员指针而导致计数器不为0），此时我们可以调用weak_ptr获取实例之后进行手动销毁注意：通过weak_ptr的成员函数lock()获取的是其引用的shared_ptr所指向的对象，并不是副本或拷贝"},{"title":"关于linux编程的一些碎碎念","date":"2023-04-02T03:45:43.000Z","url":"/2023/04/02/gcc/","categories":[[" ",""]],"content":"用了这么久了，我竟然还不知道它是怎么跑起来的QAQ gcc的常用选项 选项 作用 备注 -E 预处理指定文件 -S 编译指定的源文件 -c 编译、汇编但不链接 -o [file1] [file2] 将file2编译成可执行文件file1 -I 指定include的搜索目录 -g 编译时生成调试信息 -D 程序编译的时候指定一个宏 -w 不生成任何警告信息 -Wall 生成所有警告信息 -On n&#x3D;[0,3] 优化级别 -l 指定编译时使用的库 -L 指定编译的时候搜索的库路径 -fPIC&#x2F;fpic 生成与位置无关的代码 -shared 生成共享目标文件 -std 指定语言标准 如-std&#x3D;c99 gcc工作流程原代码(.h&#x2F;.c&#x2F;.cpp) –预处理器–&gt; 预处理后源代码 –编译器–&gt; 汇编代码(.s) –汇编器–&gt; (启动代码、目标代码、库代码、其他目标代码) –链接器–&gt; 可执行程序 静态库和动态库静态库 注意：库文件需要和对应的头文件一起使用 命名规则 linux平台前缀：lib后缀：.a windows平台前缀：lib后缀：.lib 如何打包将写好的源码通过gcc获得.o文件使用ar工具插入 ar rcs libxxx.a xxx.o,xxx.o(需要被打包的a文件，可以是多个)r:将文件插入备存文件c:简历备存文件s:索引获得libxxx.a文件 如何使用自定义静态库答：在编译时指定扫描路径gcc xxx.c -o app -I ..&#x2F;include&#x2F; -l calc -L .&#x2F;lib小小的回忆一下之前的知识：-I 指定include的搜索目录-l 指定编译的时候使用的库-L 指定编译的时候搜索的库的路径linux严格区分大小写 动态库命名规则 linux平台前缀：lib后缀：.so windows平台前缀：lib后缀：.dll 如何打包： gcc得到.o文件，即和位置无关的代码gcc -c -fpic&#x2F;-fPIC a.c b.c gcc 得到动态库gcc -shared a.o b.o -o libxxx.so从而获得libxxx.so文件 如何使用自定义动态库参照自定义静态库完成编译链接 动态库和静态库的区别是什么？静态库：代码会被打包到可执行程序中动态库：代码不会被打包到可执行程序中因此，如果一个程序使用了动态库，在其启动的时候，动态库会被动态加载到内存之中，可以通过”ldd [file]”命令检查动态库依赖关系 如何定位动态库?使用系统的动态载入器来获取绝对路径现在主流的linux动态库加载器为ld-linux.so 如何将自己的动态库添加到加载器内？ 会话级配置：直接执行export LD_LIBRARY_PATH&#x3D;$LD_LIBRARY_PATH:[new path]解释：在LD_LIBRARY_PATH内追加新动态库路径，$[]为对原有系统变量的引用缺点：在终端关闭后即失效 用户级配置：在~&#x2F;.bachrc文件中加入export LD_LIBRARY_PATH&#x3D;$LD_LIBRARY_PATH:[new path]加入后使用source .bachrc进行更新 系统级配置在&#x2F;etc&#x2F;profile中加入export LD_LIBRARY_PATH&#x3D;$LD_LIBRARY_PATH:[new path]加入后使用source &#x2F;etc&#x2F;profile进行更新(不需要sudo) 动态库和静态库的优缺点静态库优点： 静态库被打包进程序，加载速度较快 发布时直接发布程序即可，移植工作量小缺点： 占用空间较大 更新、部署、发布比较麻烦，更改其中一个文件需要重新发布整个程序 动态库优点： 可以实现进程间资源共享 更新、部署、发布简单 可以控制加载时间，使用到再加载缺点： 相对于静态库，加载速度慢 发布程序时需要提供其依赖的动态库 Makefile作用：对于一个大的项目来说，他们的依赖关系非常复杂，如果使用单挑命令进行编译，时候维护难度会相对较大，使用makefile文件，可以指定文件的编译顺序、编译选项，同时，还可以实现自动化编译，在对代码进行更改后执行make命令就可以完成编译文件名：makefile&#x2F;Makefile 规则 一个makefile文件中可以有一个或者多个规则目标…:依赖…&amp;nbsp&amp;nbsp命令….（注意制表符）目标：最终需要生成的文件依赖：生成目标所需要的文件或目标命令:通过执行命令对依赖操作生成目标(必须有缩进) 一般来说，makefile的其他规则都是为了第一条规则服务的 工作原理： 命令在执行前，会检查规则中的依赖是否存在 如果存在，则执行 如果不存在，会向下检查其他规则，如果找到了，执行 检测更新，在执行规则中的命令时，会比较目标和依赖文件的时间 如果依赖的(最后修改)时间比目标的时间晚，则需要重新生成目标 如果依赖的时间比目标的时间早，对应规则的命令不会被执行 变量自定义变量[name]&#x3D;[value] 预定义变量AR 归档维护程序的名称，默认为arCC c的编译器的名称，默认为gcccxx c++的编译器的名称$@ 目标的完整名称$&lt; 第一个依赖文件的名称$^ 所有的依赖文件…….还有很多，这里只列举常用的 获取变量的值$(变量名) 函数$(函数名 参数)比如：$(wildcatd PATTERN)…功能：获取指定目录下指定类型的文件列表参数：pattern指的是某个或多个目录下某种类型的文件返回值：得到一个文件列表，文件名之间用空格间隔示例：$(wildcard .c .&#x2F;sub&#x2F;.c) 获取当前目录与同级sub目录下的所有*.c文件名$（patsubst,&lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;）查找&lt;text&gt;中的单词是否符合&lt;pattern&gt;模式，如果匹配的话，用&lt;replacement&gt;替换示例：$(patsubst %.c,%.o,x.c bar.c)返回值格式：x.o bar.o GDBgdb是由gnu组织提供的调试工具，和gcc配套组成了一套完整的开发环境"},{"title":"linux","date":"2023-03-27T12:16:01.000Z","url":"/2023/03/27/linux/","categories":[[" ",""]],"content":"我是谁，我在哪，我在干什么 linux的目录结构 linux没有盘符的概念，只有一个 根目录 &#x2F;，所有的文件都在&#x2F;下面 linux命令入门基本格式：command [-options] [parameter] ls命令查看当前目录下内容(文件&amp;&amp;文件夹)ls [-a -l -h] [path]选项列表： -a 列出全部文件（包括隐藏的文件&#x2F;文件夹） -l 以列表方式展示文件详细信息 -h 以易于阅读的形式列出文件大小若不加path参数则展示当前目录下内容注意： linux启动的时候默认会加载当前用户的个人目录，即&#x2F;home&#x2F;${username} 以.为开头的文件会被认为是隐藏的文件 如果不加-h，文件大小默认单位为B，加上后会被优化为K,G等更大的单位 cd&#x2F;pwd命令"},{"title":"Redis","date":"2023-03-21T09:47:19.000Z","url":"/2023/03/21/Redis/","categories":[[" ",""]],"content":"喔，R！ Redis入门 redis是键值数据库(非关系型&#x2F;K-V&#x2F;NoSql数据库) 因此，可以用复杂数据类型包装value来存储复杂数据 Remote Dictionary Server-RE DI S NoSQL特性 非结构化（通过K-V） 无关联的（智能通过业务逻辑维护表间关系） 非SQL（没有通用的语法标准） 无事务，BASE理论（基本可用（Basically Available）、软状态（Soft-state）、最终一致性（Eventually Consistency）），难以满足ACID 内存存储 水平扩展 适用场景： 数据结构不固定 对一致性、安全性要求不高 对性能要求较高 Redis特征 K-V，支持数据结构较多 单线程，每个命令具备原子性 低延迟、速度快（基于内存、IO多路复用，编码良好） 支持数据持久化 支持主从集群、分片集群 支持多语言客户端 常用命令 Expire Key [time(s)] 设置某键有效期（-1为永久存在，-2为已经过期） TTL Key 查看某键剩余有效期 Keys Model 查看符合模板的所有key Del Key 删除一个指定的key Exists Key 查看key是否存在 Redis数据结构 Name Example String hello Hash {name:”jack”,age:21} List [A-&gt;B-&gt;C-&gt;D] Set {A,B,C} SortedSet {A:1,B:2,C:3} GEO {A:(120.3,36.2)} BitMap 11011 HyperLog 11011 Redis的层级格式key允许使用多个词条形成层级结构，多个词条之间使用”:”隔开层级在redis内部是真实存在的，不是通过业务分割的 String类型字符串类型，可以根据内容不同分为三类（仍然为字符串类型） string 普通字符串 int 整数 float 浮点数其中int和float可以进行自加&#x2F;自减操作如果要让一个key的value有很多属性，需要打包成json 常见命令： set 设置键值对 get 获得键值对 mset 批量设置键值对 mget 批量获得键值对 incr 让一个整型的key自增1 incrby 让一个整型的key自增并指定步长 incrbyfloat 让一个浮点型的key自增并指定步长 存在decr，但是一般都用incr加负数步长 setnx 添加一个键值对，前提是不存在，否则不执行 setex 添加键值对并指定有效期键值对有效期的场景：获取短信验证码&#x2F;二维码登录等 Hash类型如果要让一个key的value有很多属性，可以分别存储KEY (key1 value1 key2 value2…) 常见命令 hset key field value 参考string hget 参考string hmset 参考string hmset 参考string（4.0后已被禁用） hgetall 获取一个key中的所有field和value hkeys 获取一个key中的所有field hvals 获取一个key中的所有value hincrby 让一个hash的key字段自增并指定步长（只能指定integer） hsetnx 添加一个hash类型的key的field值，前提是不存在，否则不执行 List类型可以看作是双向链表，支持正向检索和反向检索特征： 有序 元素可以重复 插入和删除较快 查询速度一般 常见命令： (L&#x2F;R)PUSH key element… 向链表(左&#x2F;右)侧插入一个元素 (L&#x2F;R)POP key 移除并返回(左&#x2F;右)侧的第一个元素，没有则返回nil LRANGE key star end 返回一段角标范围内的所有元素 B(L&#x2F;R)POP 与普通类似，没有的时候会等待指定时间，不会返回nil Set类型底层类似Java中的HashMap 无序 数据不可重复 查找较快 支持交&#x2F;并&#x2F;差等功能 常用命令： SADD key member 添加一个或多个元素 SREM key member 移除指定元素 SCARD key 返回元素个数 SISMEMBET key member 判断是否存在 SMSMBERS 获取set中的所有元素 SINTER set1 set2 求交集 SDIFF set1 set2 求差集 SUNION set1 set2 求并集 SortedSet 可排序集合底层数据结构为跳表+hash表每一个元素都带有score属性，根据score进行排序 有序 数据不重复 查询较快 常用命令：SortedSet的常见命令有: ZADD key score member:添加元素，如果已经存在则更新其score值在一个命令中添加多个元素时： ZREM key member:删除集合中的一个指定元素 ZSCORE key member:获取集合中的指定元素的score值 ZRANK key member:获取集合中的指定元素的排名 ZCARD key:获取集合中的元素个数 ZCOUNT key min max:统计score值在给定范围内的所有元素的个数 ZINCRBY key increment member: 让集合中的指定元素自增，步长为指定的increment值 ZRANGE key min max:按照score排序后，获取指定排名范围内的元素 计数器从0开始 ZRANGEBYSCORE key min max:按照score排序后，获取指定score范围内的元素 ZDIFF、ZINTER、ZUNION:求差集、交集、并集 所有的查询默认为升序，如果需要降序则将命令改为ZREVxxx"},{"title":"STL容器简介","date":"2023-03-17T09:03:34.000Z","url":"/2023/03/17/STL/","categories":[[" ",""]],"content":"STL一共有 7 种序列容器， 4 种关联容器， 4 种无序关联容器 首先明确定义：什么是容器？ 容器是存储其他对象的对象 容器贯彻了C++泛型编程的思想，结合OOP理念 底层实现：类与模板 忘记了可以来开天辟地（bushi）C++笔记 注意，在不加其他限制措施的情况下，任何STL容器都是线程不安全的 序列容器序列的基本方法： 方法 含义 备注 insert() 插入一个对象 erase() 删除一个对象 需要传入迭代器 clear() 清空序列内容 元素按照线性顺序排列 vector 动态数组 支持随机访问且速度较快 可以根据数组长度动态申请内存大小 在尾部添加和删除元素的时候是固定时间复杂度 在头部添加和删除元素的时候是线性时间复杂度 可反转 deque 双端队列 支持随机访问 在首位添加或删除元素的时候是固定时间复杂度（效率低于vector） 可反转 list 双向链表 不支持随机访问 任意插入或删除都是线性时间复杂度 存在sort成员函数 forward 单向链表 不支持随机访问 不可反转 在C++11后提供 queue 队列 性质如其名 为deque的封装 priority_queue pq(greater) 优先队列 底层使用堆实现 队列内数据有序 性质如其名 stack 栈 性质如其名 为deque的封装 关联容器 保存k-v数据 元素保存有序 查询性能和插入性能较稳定，一般为log级 一般底层使用树存储 set 集合容器 没有kv，k就是v 可反转 可排序，默认升序 键唯一，不可重复 提供交并差运算(略复杂) multiset 多重集合 在set的基础上允许重复 map 映射 k-v结构，键不可重复 查询和插入都是稳定的log(n) 可反转，有排序 multimap 多重映射 在map的基础上允许重复 无序关联容器（哈希容器） 保存k-v数据 元素保存无序 查询与插入性能优异，一般为O(1) 遍历性能较差 一般底层使用哈希存储 "},{"title":"maven笔记","date":"2023-02-21T06:45:25.000Z","url":"/2023/02/21/maven%E7%AC%94%E8%AE%B0/","categories":[[" ",""]],"content":"喔，填坑呢在这 组成 坐标 groupId 隶属组织名称 artifactId 当前项目名称 version 当前版本号 packaging 打包方式（默认为jar） 作用：唯一定位该资源，查找、下载并使用资源 配置 环境变量MAVEN_HOME 可以配置settings.xml（全局生效），也可以配置pom.xml（对当前项目生效） 本地仓库配置… 配置镜像仓库（加速下载，常用阿里云仓库）… 依赖 项目可以依赖项目 项目可以依赖现成的包 依赖中存在的问题： 路径优先:当依赖中出现相同的资源时，层级越深，优先级越低，层级越浅，优先级越高 声明优先:当资源在相同层级被依赖时，配置顺序靠前的覆盖配置顺序靠后的 特殊优先:当同级配置了相同资源的不同版本，后配置的覆盖先配置的 可选依赖 场景：不希望别人知道我用过这个依赖 true 效果：当前项目使用该依赖，但依赖该项目的项目不自动引用该依赖 排除依赖 场景：不希望使用某依赖 在一个dependency里写： 效果：若当前项目排除了依赖项目的A依赖，则该A依赖不会被当前应用所依赖 依赖范围：注意：依赖范围具有传递性 scope 主代码 测试代码 打包 compile(默认) 1 1 1 test 0 1 0 provided 1 1 0 runtime 0 0 1 生命周期与插件clean 清理 pre-clean clean post-cleandefault 核心工作（编译、测试、打包、部署） site 产生报告 pre- site post-site site-deploy 插件：与生命周期相绑定或者可以说maven的每一个生命周期都是利用插件来实现的 引入引入方式同依赖，只不过把dependency改成plubins&#x2F;plugin&lt;groupId&gt;…&lt;&#x2F;groupId&gt;&lt;artifactId&gt;….&lt;&#x2F;artifactId&gt;&lt;version&gt;…&lt;&#x2F;version&gt; 目标设置&lt;executions&gt;…&lt;&#x2F;executions&gt;下层：指令&lt;&#x2F;goal&gt;运行阶段&lt;&#x2F;phase&gt;即为在哪个生命周期中执行该插件 分模块开发与设计总目标：将程序拆装成不同模块，利用接口通信 （不是java的接口）controller 控制层service 业务层dao 持久层pojo 展示层 聚合依赖用一个模块来管理其他模块 设置聚合模块打包方式为pom &lt;modules&gt;被聚合的工程列表&lt;&#x2F;modules&gt; 继承 模块依赖关系维护 子模块可以声明需要依赖，但是不限定版本，若出现版本冲突则会难以解决 解决方案： 在聚合模块中声明所有的依赖 在子模块中声明&lt;parent&gt;工件ID&#x2F;版本&#x2F;GroupId….&lt;&#x2F;parent&gt; 子工程在设计dependency时不需要写version继承的作用：子工程中沿用父工程的依赖配置 属性定义自定义属性 版本管理 关于版本号命名的小常识 snapshot 开发过程中，为方便合作或解决依赖等，输出的临时性版本，会随着开发的进展不断更新，更新周期较短 release 经过测试后，团队对外发布的，运行较为稳定的版本，更新周期较长 关于版本号的一些约定：&lt;主版本&gt;&lt;次版本&gt;&lt;增量版本&gt;&lt;里程碑版本&gt; 如：5.1.13-Release 多环境开发配置-不需逐个更改文件即可兼容（生产环境&#x2F;开发环境&#x2F;测试环境……） 执行特定环境方法：mvn -P [环境名称] 跳过测试 常用场景： 模块功能未开发（完毕） 单个功能更新导致其他功能失效 快速打包 方式 在maven配置窗口跳过 mvn -D skipTests 在pom中配置测试插件(maven-surefire-plugin)，设置&lt;skipTests&gt;true&lt;&#x2F;skipTests&gt;(不建议使用) 只使用部分用例测试 在测试插件(maven-surefire-plugin)的configuration中，设置include-对应的测试用例(.java) "},{"title":"Spring笔记","date":"2023-02-05T13:46:09.000Z","url":"/2023/02/05/Spring%E7%AC%94%E8%AE%B0/","categories":[[" ",""]],"content":"Spring框架笔记 开闭原则（Open Cloce Protocal, OCP）：软件应对扩展开放，对修改关闭 依赖倒转原则（Dependency Inversion Principle, DIP）： 高层模块不应该依赖低层模块，二者都应该依赖其抽象 中心思想：面向接口编程，面向抽象编程 目的：降低程序耦合，提高扩展性能 控制反转 编程思想（Inversion of Control, IoC） 不在程序中采用硬编码的方式来新建对象 不在程序中采取硬编码的方式来维护对象关系 由于出现较晚，没有被纳入GoF23种设计模式范围内 实现方式较多，其中比较重要的有：依赖注入（Dependency Injection, DI） IoC是思想，DI是实现 注入方法：Set方法注入&#x2F;构造方法注入 set注入 构造方法注入 Spring框架 实现控制反转IoC，协助新建对象&#x2F;维护对象关系 实现IoC思想的容器 八大模块： Core: 基于IoC的核心，实现对Bean的管理，主要组件是BeanFactorty AOP: 次核心，面向切面编程 Web MVC: Spring自己提供的一套MVC框架（暨SpringMVC） WebFlux: 响应式Web框架 Web: 支持集成常见的Web框架（如struts，webwork） DAO: 提供了单独的支持JDBC操作的API ORM: 支持集成常见的ORM框架（如MyBatis,Hibernate） Context: 提供扩展服务 特点 轻量 非侵入式：Spring应用中对象不依赖Spring的特定类 轻量：体积小 控制反转：底层使用工厂模式（XML解析+工厂模式+反射机制） 面向切面 容器 框架 pom.xml packaging 打包方式 repositories 仓库地址 dependencies 依赖 Spring的配置文件 放在resources目录下的xml文件 配置标签，让spring创造对象 bean的两个重要属性： id bean的唯一标识符 类的全限定类名（带包名） Spring容器的使用 获取Spring容器对象：ApplicationContext ac&#x3D;new ClassPathXmlApplicationContext(“配置文件路径”) 注意：运行上一行句内代码即视为启动Spring容器，解析xml文件，并实例化其所有的Bean对象 根据BeanID获取对象：ac.getBean(“Bean的ID”,bean类型.class); 参数2若留空，返回类型默认为Object spring框架通过反射机制来创建对象→一定要保证无参构造方法存在 Class cz&#x3D;Class.forName(“完整类名”) Object obj&#x3D;cz.newInstance() 底层使用Map&lt;String,Object存储&gt; 同一个xml文件内不可以有同id的bean，若同时加载多个xml后，存在同id的bean，后加载的bean的会覆盖先加载的bean，被覆盖的bean不会被实例化（猜测：也许是先加载完所有的bean然后再统一实例化？） getBean的时候不可以虚空索敌，会报错 启动Log4j2日志框架 引入依赖 创建xml配置文件 在项目内记录日志信息 创建日志记录器对象 根据不同级别输出日志 set注入详解 注入外部Bean：外部定义好bean，property中使用ref引用 注入内部Bean：在内部property中嵌套定义bean，不用写ref(少用) 注入简单类型（如int，char，enum等）：property中不指定ref，property指定value Date虽然可以使用value赋值，但对于格式有着严格的要求，如Mon Feb 6 14:50:17 CST 2023，所以尽量还是用ref 级联属性赋值：\\&lt;property name=id.属性 value=&quot;&quot;/\\&gt; 注意：如果想要使用级联属性赋值，需要编写对应id-bean的get方法 注入数组：property内嵌array，使用value&#x2F;ref填充 注入List&#x2F;Set&#x2F;Map&#x2F;属性类 注入null和空字符串 命名空间注入 p命名空间注入 目的：简化配置 基于set注入 配置文件头：xmlns:p&#x3D;” c命名空间注入 目的：简化配置 基于构造方法注入 配置文件头：xmlns:p&#x3D;” util命名空间实现配置复用 配置文件头：xmlns:p&#x3D;” 更改schemaLocation:www.springframework.org/schema/util ; 基于XML的自动装配 根据名字进行自动装配，底层基于set方法 被自动注入的bean的id需要和set方法中的name一致（去掉set首字母小写） 根据类型进行自动装配，底层基于set方法 一个类型的对象只可以有一个 引入外部properties文件 配置文件头，引入context命名空间：xmlns:p&#x3D;” 更改schemaLocation:www.springframework.org/schema/context ; 使用context:property-placeholder的location属性指定路径，从根目录开始寻址 resources相当于根目录 使用${key}取值，保留双引号 警惕系统变量乱入. bean的作用域 scope项： Spring默认是单例的，即singleton，启动容器时即创建对象 将bean的scope属性设置为prototype则为多例，此时每一次getBean则实例化一次 若引用SpringMVC框架，可有request（一次请求一个bean）和session（一次会话一个值） 还有其他少用scope项 如global session(portlet应用专用)\\application(一个应用)\\websocket(一个生命周期)\\自定义 bean的实例化 构造方法实例化-自动调用无参构造方法 简单工厂模式实例化 factory-bean实例化 FactoryBean接口实例化 Bean的生命周期 实例化 Bean属性赋值2.5 检查Bean是否实现了Aware相关接口，并设置相关依赖 执行“bean后处理器”的before方法3.5 检查Bean是否实现了InitializingBean接口，调用方法 初始化bean（xml中配置init-method&#x3D;””） 执行“bean后处理器”的after方法 使用bean6.5 检查Bean是否实现了DisposableBean接口并调用接口方法 销毁bean（xml中配置destroy-method&#x3D;””） bean后处理器: implements BeanPostProcessor并重写其before和after方法，写完在xml中创建该bean即可 一旦配置则对当前xml所有的bean都生效 作用：检查Bean是否实现了某些特定的接口 Spring容器仅对singleton的bean进行完整的生命周期管理，其他scope只负责初始化完毕 Bean的循环依赖 spring仅可以自动处理set注入&#x2F;singleton情况下的循环依赖问题 构造注入&#x2F;(singleton&#x2F;prototype&#x2F;Others)情况下__无法解决__原理：调用无参构造方法实例化对象（此时即曝光该Bean对象），然后使用set注入 Bean的三级缓存private final Map&lt;String,Object&gt; singletonObjects 一级缓存private final Map&lt;String,Object&gt; earlysingletonObjects 二级缓存private final Map&lt;String,ObjectFactory&lt;?&gt;&gt; singletonFactories 三级缓存(该map集合即被称为缓存)key为bean的idvalue:一级缓存：经过注入后完整的bean对象二级缓存：已经被实例化，但是还没有赋值属性的bean对象三级缓存：单例工厂对象 Spring IoC 注解式开发目的：简化XML配置使用方式：在配置文件中添加aop依赖，配置context命名空间，配置扫描，在类上只用注解 选择性实例化bean "},{"title":"About-2023","date":"2023-02-01T14:18:58.000Z","url":"/2023/02/01/About-2023/","categories":[[" ",""]],"content":"在这个世界，有一点希望 有一点失望，我时常这么想 这个世界-孙燕姿2023才刚刚开始，歌曲可能会随每月心情而更改;-) 今年更是全新开坑的一年！我决定年初就开始写总结！ 一月份 双板滑雪入门之在中级道被鱼类创飞！ 从0开始的python生活 二月份 为什么周围人都这么卷啊 Spring！ 从0开始的实习生活 得到又失去，相遇却别离，或许重逢，或许再而不见 开学🌶 三月份 楞学C++ 周围人都好卷啊 找不到实习了嘤嘤嘤 四月份 放弃找实习，专心学技术 "},{"title":"pgsql","date":"2023-01-28T12:17:18.000Z","url":"/2023/01/28/pgsql/","categories":[[" ",""]],"content":"大二没好好学呜呜呜 SQL 备忘录SQL 备忘录 基本语句格式 select from where group by 按照一定规则分组，可以有多个参数 多参数时，若两参数的参照关系完全相同，会归为一类 多参数时，会按照设置的参数项目对结果进行分类 必须与聚合函数（count()\\sum()等）搭配使用，否则会报错 order by 按照一定规则排序 order by colomn [asc|desc] asc:Ascend 升序 desc:Descend 降序 关键字 distinct 保证结果（根据某一列&#x2F;多列）严格不相同 join 连接 见6 as 为某项数据设置别名，一般在存在复杂子查询时使用 exists 后接内层子查询，返回结果为Yes或No，若外层查询到的数据在内层中满足条件的出现过，则返回Yes limit 用在from后：可以设置搜索的偏移量，提升搜索效率，select * from table limit 起始行,向后偏移量（-1则搜索到表结尾） 用在where后：限制结果数量，搜索到指定数量的记录后即停止搜索，避免搜索全表 select * from table where colomn&#x3D;? limit 1 union 用在两个select整体之间，用来连接搜索结果，要求被连接的两个表拥有严格相似的结构 in&#x2F;not in 用于限制条件，可以限制搜索目标in(ans1,ans2,ans3……) like &amp;&amp; ilike 见7 having 过滤搜索结果，见8 内置函数 generate_series(start, stop, step),可以用于数字&#x2F;时间的序列生成，step可以为除了0以外的任何实数 row_number() over (order by colomn [asc|desc]) 对于某列的数据按照[升序|降序]生成序列，遇到相同数据不会生成重复序号 rank() over (order by colomn [asc|desc]) 对于某列的数据按照[升序|降序]生成序列，遇到相同数据会生成重复序号，相同的数据只占用一个名次 dense_rank() over (order by colomn [asc|desc]) 对于某列的数据按照[升序|降序]生成序列，遇到相同数据会生成重复序号，相同的数据占用多个名次 NTILE(number) over (order by colomn [asc|desc]) 对于某列的数据按照[升序|降序]生成序列，每个数字项出现number次 聚合函数 count sum 范式 1NF 数据是不可再分的 解决方法：拆数据项 2NF 在1NF的基础上，消除了非主属性对于码的部分函数依赖，即保证通过主键可以唯一确定该项每一列的值 解决方法：拆表 3NF 在2NF的基础上，一个表中不可以存在任何非主属性可以被另一项非主属性唯一确定 解决方法：进一步拆表 表达式 case表达式 简单case表达式 连接 inner join left (outer) join right (outer) join full outer join粗浅的理解：先发生表结构拼接 join 中文 粗浅的理解 备注 inner join 内连接 A交B left (outer) join 左(外)连接 A并(A交B) B表中没有的内容留空 right (outer) join 右(外)连接 (A交B)并A A表中没有的内容留空 full outer join 全外连接 A并(A交B)并B AB中互相没有的留空，然后补齐在总表下方 A join B on 匹配条件仅保存符合匹配条件的数据库记录 通配符与模糊搜索 like &amp;&amp; ilike like在搜索时区分大小写 但ilike不区分 两个通配符 _ 占位通配符，该通配符出现的次数严格匹配目标的格式，如_0，则目标字串的第二位一定为0 % 不占位通配符，该通配符出现的地方不限制字符数字，可以为0-n个字符填充，如%0，此时目标串含有0则会被选中语句示例：select * from table where colomn like ‘%_00’ like可以用于复制一张表的结构 （不包含数据） create table table2(like table1) having的用法 区分having和where： where是直接在搜索的时候进行筛选，having是过滤搜索结果 执行顺序：where-→聚合函数-→having having后面可以使用聚合函数，但where不可以 "},{"title":"C++笔记","date":"2023-01-17T09:15:50.000Z","url":"/2023/01/17/C/","categories":[[" ",""]],"content":"有人查漏补缺，有人精卫填海，有人开天辟地(bushi 内存的分区模型代码区：存放函数体的二进制代码全局区：存放全局变量、静态变量、常量栈区：由编译器自动分配&#x2F;释放，存放函数参数和局部变量等堆区：由程序员分配和释放，若未释放则在程序结束时由操作系统回收 代码区的特点：共享（多次执行只需要一份代码即可），只读（防止意外修改）全局区的特点：数据在程序结束后由操作系统释放栈区的特点：保存在栈区的数据在函数执行完即自动释放堆区的特点：用new开辟，由程序员指定分配 引用（给变量起别名）,指向同一片内存空间意义：要求： 一定要初始化 一旦初始化了，就不可以更改了 参数传递 值传递 地址传递 引用传递 引用作函数返回值含义：如果一个函数的返回值是引用，那么这个函数可以作为左值 不要返回局部变量的引用 引用的本质：一个指针常量，指针不可以修改，但是指针指向的值可以修改由编译器完成（引用→指针常量）的过程常量引用：使用场景：用来修饰形参，使其只读，防止误操作 函数进阶函数的默认参数类型 名（参数名&#x3D;默认值）{} 若某位置有默认值，则该位置往后必须全部有默认参数（规定） 声明和实现只可以有一个有默认参数（规定） 如果函数参数值&gt;传入参数值，则从第一个参数开始向后填充，若某参数未被填充且没有默认值，则会报错 函数的占位参数调用函数时必须填补该位置 函数重载满足条件： 同一个作用域下 函数名称相同 函数参数(类型&#x2F;个数&#x2F;顺序)不同 函数返回值并不作为函数重载的条件注意事项： 引用可以作为重载的条件 重载遇到默认参数时，警惕UB（二义性）报错 面向对象基本特性：继承、多态、封装 struct和class的区别： struct的默认权限为公共 class默认权限为私有 构造函数的分类和调用调用方式： 拷贝构造函数的调用时机 使用一个对象来初始化另一个对象 以值传递的方式给函数参数赋值 自动调用拷贝构造函数创造副本 以值方式返回局部对象 此时被返回的对象会被拷贝构造 构造函数调用规则 默认存在构造函数、析构函数、拷贝构造函数 如果定义有参构造函数，只会提供默认拷贝构造 如果定义拷贝构造函数，不会提供其他构造函数 深拷贝和浅拷贝浅拷贝：简单的复制拷贝，默认的拷贝构造函数拷贝方法 容易带来的问题：若存在堆区空间的操作，容易造成重复释放与重复操作深拷贝：在堆区重新申请空间，进行数据拷贝 初始化列表qwq():a(10),b(20){}&#x2F;&#x2F;一个让a的默认值为10，b的默认值为20的无参构造函数qwq(int a,int b):a(a),b(b){}&#x2F;&#x2F;一个让a的值为a，b的值为b的有参构造函数 类对象作为类成员 静态成员静态成员变量特点： 所有对象共享统一数据 在编译阶段即分配内存 类内声明，类外初始化 仍然存在访问权限 静态成员变量访问方式： 通过对象进行访问 通过类名进行访问 静态成员函数特点： 所有对象共享同一个函数 静态成员函数只能访问静态成员变量 存在访问权限静态成员函数调用方法： 通过对象进行访问 通过类名进行访问 C++对象内存模型和this指针只有非静态成员变量才属于类的对象成员变量和成员函数是分开存储的静态成员变量和成员函数只有一份拷贝this指针：指向被调用的成员函数所属的对象奇怪的用法：可以使用空指针调用成员函数 const修饰成员函数 const修饰的函数成为常函数 常函数不可以修改成员属性 可以修改有关键字mutable的成员变量 友元关键字： friend作用：让一个函数或者类区访问另一个类的私有成员三种实现方式： 全局函数作友元 类作友元 成员函数作友元 运算符重载作用：对已有的运算符进行重新定义，以适应不同的数据类型函数名：operator*(被重载的运算符)注意： 对于内置的数据类型的运算是不可以重载的 不要滥用，尽量让运算符和实际作用相符 加号运算符重载 左移运算符重载 递增运算符重载 赋值运算符重载知识点：C++编译器会给一个类添加赋值运算符&#x3D;对属性进行值拷贝（默认为浅拷贝） 复习！浅拷贝在什么情况下会出问题！ 答：涉及到堆区内存申请&#x2F;释放的时候 函数调用运算符()重载&#x2F;&#x2F;因为长得真的很像自定义函数，又称之为仿函数&#x2F;&#x2F;仿函数没有固定写法，非常灵活 继承基本语法：class 派生类名：继承方式1 基类1,继承方式2 基类2……C++中一个类可以由多个类派生而来多继承中如果涉及到同名问题，加作用域以访问不同父类中的成员但是在实际开发中不建议使用多继承 继承方式继承后private成员不可用，成员权限会有所改变 公有继承 不改变权限 私有继承 public&amp;protected-&gt;private 保护继承 public-&gt;protected 继承中的对象模型基类所有的非静态成员变量，在派生类中仍然存在，只是被编译器隐藏了 继承中构造和析构顺序继承后在类初始化时，基类和派生类的构造函数和析构函数都会被分别调用具体调用顺序：先调用基类构造函数，再调用派生类构造函数，析构函数顺序相反 继承中同名成员的处理方式在继承后，同名成员会共存（静态成员也是）访问派生类中同名成员，可以直接访问访问基类中同名成员，需要加作用域如果基类和派生类中存在同名函数，父类中同名函数会被隐藏，如果要访问，需要加作用域 菱形继承定义：两个派生类继承同一个基类，某个类同时继承这两个派生类可能导致的问题：数据重复，资源浪费解决方案：虚继承（在第一次继承的两个派生类上发生）(关键词virtual)vbptr（Virtual Base Pointer）:虚基类指针，指向虚基类表 指针占4个内存嗷采用虚继承后，来自同一个上层基类的数据会只存在一份拷贝，对于直接继承的两个基类，存在一个vbptr，指向虚基类表中的偏移量，即为那一份拷贝在多少位之后 多态 静态多态：函数重载和运算符重载，复用函数名，依靠传入参数类型和个数区分 编译阶段确定函数地址 动态多态：派生类和虚函数实现运行时多态 运行阶段确认函数地址如何实现动态多态？函数前加virtual关键字，使其变成虚函数class animal{public: virtual void speak(){ cout&lt;&lt;”animal speak”; }}class cat: public animal{public: virtual void speak(){ cout&lt;&lt;”cat speak”; }}class dog: public animal{public: virtual void speak(){ cout&lt;&lt;”dog speak”; }}void doSpeak(Animal &amp;animal)&#x2F;&#x2F;也可以是指针{ animal.spaek(); &#x2F;&#x2F;可以传入animal,dog,cat &#x2F;&#x2F;此时若调用doSpeak函数，会根据传入的参数选择调用哪一个类中的speak函数} 内部实现vfptr(Virtual Function Pointer):虚函数指针指向虚函数表vftable(Virtual Function Table)虚函数表内容：函数-&gt;入口地址动态多态的原理：每个类都维护一个虚函数表（函数-&gt;入口地址），如果它重写了父类的函数，那么会用新函数的地址替代旧函数的地址以上文的代码为例，cat类重写了speak函数，当cat被传入doSpeak函数中时，调用animal.speak，此时animal是对该cat对象的引用，所以会从cat类的虚函数表中查找speak函数，查找到的就是输出”cat speak” 纯虚函数virtual 返回值类型 函数名 (参数) &#x3D;0;有纯虚函数的类一定是抽象类，无法被实例化，子类必须重写纯虚函数可以类比java中的abstract方法 虚析构和纯虚析构现存的问题：使用多态时，若子类有属性在堆区需要在析构函数时调用delete释放，那么父类指针在释放时(delete 父类;)无法调用到子类的析构代码，只会调用父类的析构函数解决方法：将父类的析构函数改为虚析构或者纯虚析构 虚析构和纯虚析构的共性： 可以解决堆区内存释放问题 需要有具体的函数实现区别： 有纯虚析构的类为抽象类，无法被实例化，派生类必须重写析构函数 C++ 文件操作包含库：文件分为两种： 文本文件 二进制文件操作文件的三大类： ofstream 写操作 ifstream 读操作 fstream 读写操作总体操作流程创建流对象-&gt;open(“path”,way)-&gt;写入数据-&gt;close|—-|—-||打开方式|解释||ios::in|为读文件而打开文件||ios::out|为写文件而打开文件||ios::ate|初始位置：文件尾||ios::app|追加方式写文件||ios::trunc|先删除，再创建新的||ios::bindry|以二进制方式打开文件| 可以使用|运算符，同时以多种方式打开文件 C++提高编程泛型编程（模板）建立一个通用模具，提高代码复用性 函数模板 使用方法： 注意事项： 自动类型推导，必须推导出一致的数据类型t才可以使用 类型的一致性 模板必须要确定出T的数据类型才可以使用 模板对应的函数必须指出T的数据类型 函数模板和普通函数的区别： 普通函数调用可以发生隐式类型转换 函数模板如果使用自动类型推导，不会发生隐式类型转换 函数模板如果使用显式指定类型，可以发生隐式类型转换 函数模板调用规则 如果函数模板和普通函数都可以实现，优先调用普通函数 可以通过空模板参数列表来强制调用函数模板 函数模板也可以发生重载 如果函数模板可以更好的匹配，优先调用函数模板总结：尽量不要让模板和普通函数功能重合，容易产生二义性 模板的局限性对于特定数据类型（class等），需要具体化方式做特殊实现常见相关解决方法：运算符重载（治标不治本）、具体化实现 类模板 类模板和函数模板的区别 类模板不可以采用自动类型推导的使用方式 类模板在模板参数列表可以有默认参数 成员函数创建时期 成员函数在调用时才被创建可能出现的情况：模板类中定义的函数，在模板被实现后无法被调用换种说法，若出现该类问题，不会在编译时被编译器查出 类模板对象作函数参数传入方式： 指定传入的类型 直接显示对象的数据类型 参数模板化 将对象中的参数变为模板进行传递 整个类模板化 将这个对象类型模板化进行传递 类模板与继承 当子类继承的父类是一个类模板时，子类在声明时需要指定T的类型 如果不指定，编译器无法给子类分配内存 如果想灵活指定T的类型，子类也需要为类模板 类模板成员函数的类外实现 类模板分文件编写问题：成员函数在调用阶段生成，导致分文件编写时无法被链接解决方案： 直接包含cpp源文件（会通过.cpp的头文件自动包含.h文件） 将声明和实现写到同一个文件中，并更改后缀名为hpp（约定） 类模板与友元类内实现：直接在类内声明友元即可类外实现：提前让编译器知道全局函数存在 "},{"title":"About 2022","date":"2022-11-27T13:54:30.000Z","url":"/2022/11/27/About-2022/","categories":[[" ",""]],"content":"永恒是颗虚伪的糖，任回忆终堆积成墙。 是谁说了谎，还要一直伪装 Hello-龚言脩也是上文中歌词的出处 好像上一秒还在2021跨年夜，转瞬间2022都快结束了今天是11月27日，济南站结束，大学的ICPC奋斗史也划上了一个句号，思绪万千，但不知道该从哪里写起，索性就提前把坑开好，之后慢慢找补吧 一月份 去上海玩了一圈，这是人生第一次自己去想去的地方旅游，和两个🐖一起 多校，一周四场，补题补得像是人间炼狱 二月份-五月份 赶着开学前把阑尾切掉了，本来想借着手术得由头晚几天返校，谁知道一晚就是三个月，五月初才返校 好像这几个月除了csgo技术见涨以外没有什么收获 四级裸考一次过(知道自己很弱，大佬们求轻喷):( 六月份 工程训练好像挺有意思的 从零开始的期末考试 系统分析与设计、计算机网络、操作系统 在家做的课设，还有答辩，录屏是真的无聊哇 七月份-八月份 和傻狗（@Yongtai）一起鬼混了两个月 九月份-十月份 转眼大三了，普通的上课生活 十一月 ICPC济南站铁牌，做了五道题，过了两道题，哎 TAT 新生赛顺利举办，撒花，协会纳新完成，协会的事情以后就交给大二同学们管了 期末还是一如既往的早呀，十一月十几号就把项目管理和软件测试考完了 我是不可能挂科的！ 十一月打完了九月开始的5E定级 2100!水平还在! 十二月 502被收了，完结撒花，协会解散吧，都别活 课设，是在做课设吗？是在渡劫 得新冠啦，虽然没发烧，但是身上没劲，头疼流鼻涕，呜呜呜 见证历史，但买不到抗原 "},{"title":"Hello","date":"2022-11-26T08:20:22.000Z","url":"/2022/11/26/Hello/","categories":[[" ",""]],"content":"这个网站是怎么来的呢? 这个域名(lxy12138.com)是在2014年被第一次注册的。在一开始的三年，站点部署在47姐姐的私人服务器上（感谢47姐姐的慷概解囊）大概从2018年开始，由于各种原因，站点不再更新，也一度陷入停站状态，仅保留了域名邮箱的使用:-( (高中真的又忙又穷谁有时间天天管一个网站嘤嘤嘤)在2022年末，由于懒狗赵石突然决定做些什么事情，于是，他重建了这个网站也就是现在你看到的，赵石的小窝 V2.0 嗨，别来无恙啊;-) Reach me at: &#115;&#x74;&#x7a;&#x32;&#x30;&#49;&#x35;&#64;&#x6f;&#x75;&#x74;&#108;&#x6f;&#x6f;&#x6b;&#x2e;&#99;&#111;&#109;"}]